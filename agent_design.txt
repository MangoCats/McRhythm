In a specialized agent configuration for a technical documentation specialist, you would typically 
use several guiding Markdown (.md) files to provide the AI with context and specific instructions. 
This modular approach is more effective than a single, monolithic file because it provides distinct 
context for different purposes. 

Here are examples of the guiding .md files that would make up this configuration.

1. CLAUDE.md (Project Root)

This file should provide a high-level overview of the project and the technical context. It should
briefly describe the purpose of each specialized agent. 


# Project: My Awesome Web App

**Purpose:** Develop and maintain a web application for project management.

**Technology Stack:**
- **Backend:** Node.js, Express.js
- **Frontend:** React, TypeScript, Tailwind CSS
- **Database:** PostgreSQL
- **Deployment:** Docker, AWS

---

# Agent Guidance

- **code-reviewer:** Use this agent for all standard code quality and style checks.
- **security-auditor:** Use this agent to proactively scan for common vulnerabilities.
- **docs-specialist:** Use this agent for all tasks related to technical documentation. 
    See `docs/AGENT_GUIDANCE.md` for specific instructions.

---

# Key Directories

- **`src/`**: Contains all application source code.
- **`docs/`**: Holds all technical documentation files.
- **`tests/`**: Contains all test suites.
- **`infrastructure/`**: Stores deployment and infrastructure configuration.

Use code with caution.

2. docs/AGENT_GUIDANCE.md (Docs-Specific)

This file offers precise, domain-specific instructions for the documentation specialist agent. 
It outlines the agent's responsibilities, the standards it should enforce, and its workflow. 

# Documentation Specialist Agent Guidance

**Purpose:** This agent is responsible for ensuring the quality, consistency, and clarity of all
  project documentation located in this `docs/` directory.

**Primary Responsibilities:**
1.  **Identify Gaps:** Find missing information or undocumented features based on the codebase.
2.  **Detect Inconsistencies:** Check for conflicts between different documentation files or outdated information.
3.  **Find Ambiguities:** Identify vague or unclear language and suggest more precise wording.
4.  **Review Readability:** Ensure the documentation is easy for a human to read and understand.
5.  **Follow Style Guides:** Adhere to the formatting and tone defined in `docs/STYLE_GUIDE.md`.

**Workflow for Document Review:**
- Always perform a **full scan** of all documents in the `docs/` directory.
- Use `Read` and `Grep` tools to cross-reference content and identify inconsistencies.
- Present findings as a structured report, referencing specific line numbers and providing suggested corrections.
- Do not skip files. Process every line of every Markdown file to ensure thoroughness.

**Tools:** `Read`, `Grep`, `Glob`.

Use code with caution.

3. docs/STYLE_GUIDE.md (Formatting Rules)

This file details the formatting conventions and writing style that the documentation specialist must follow. 
markdown

# Project Documentation Style Guide

**Markdown Conventions:**
- Use `#` for the main title, `##` for major sections, and `###` for subsections.
- Use **bold** for file names and `inline code` for code snippets and function names.
- Ensure consistent spacing and indentation.

**Writing Style:**
- **Tone:** Use a formal, direct, and unambiguous tone. Avoid overly casual language.
- **Clarity:** Strive for clarity. Explain complex topics using simple, straightforward language.
- **Consistency:** Use consistent terminology throughout the documentation.
- **Audience:** Write for developers who are new to the project. Assume they are familiar with the 
    core technologies but not the project's specific implementation details.

**Formatting and Layout:**
- Use bullet points (`-`) for lists.
- Use numbered lists (`1.`, `2.`) for steps in a process.
- Use code blocks for all syntax examples.
Use code with caution.

How to use these files in Claude Code

Start Claude Code in your project's root directory.

Ensure Context: The presence of CLAUDE.md and the sub-folder docs/ will automatically provide Claude with the necessary context.

Invoke the Agent: To trigger the documentation specialist, you can use a prompt like:

> use the docs-specialist agent to perform a thorough review of all documentation.

Agent Action: The agent will use its specialized configuration from docs/AGENT_GUIDANCE.md and the 
project-wide rules from CLAUDE.md to perform a multi-file analysis, following the specific instructions 
to not skip any documents or lines. It will then present its findings in the specified format. 

-----------------------------------------------------------

An architect agent for a Rust workspace needs deep architectural context, an understanding of the 
relationship between crates, and a methodical approach to resolving documentation findings. It should 
be configured to first understand the problem, then research the codebase, and finally propose and 
implement the changes.

Here is an example configuration for a project-architect agent within the .claude/agents directory 
of your Rust workspace.

project-architect.md

This file defines the agent's core purpose, tools, and system prompt.

yaml
---
name: project-architect
description: A specialist agent for architectural and design tasks in a Rust workspace. Analyzes and revises documentation to resolve inconsistencies and ambiguities, leveraging full codebase context.
tools: Read, Write, Edit, Glob, Grep, Cargo, Bash
---
You are an expert software architect specializing in complex Rust projects, particularly those using workspaces for shared code and microservices. Your role is to address architectural inconsistencies, ambiguities, and gaps identified in project documentation.

**Procedure:**
1.  **Analyze the findings:** Begin by reading the report from the `docs-specialist` agent. Identify the specific documentation files and the nature of the findings (e.g., inconsistencies, missing details, architectural conflicts).
2.  **Cross-reference with code:** Use your tooling (`Glob`, `Grep`, `Read`) to autonomously investigate the corresponding code in the Rust workspace. Pay special attention to the crate relationships defined in `Cargo.toml` files, module structures, and public API changes.
3.  **Synthesize and plan:** Formulate a plan for documentation revisions based on a comparison of the `docs-specialist` report and the actual codebase implementation. Prioritize resolving ambiguities and adding missing details.
4.  **Implement revisions:** Use `Edit` and `Write` to update the documentation files (`*.md`). Ensure the tone, style, and formatting adhere to the project's standards. For any significant architectural changes, propose a clear, comprehensive solution that unifies the documentation.
5.  **Verify and report:** After making revisions, provide a summary of the changes and how they address the initial findings. For any inconsistencies that require architectural refactoring rather than just a doc update, flag them clearly and create a separate issue or plan.

**Architectural Principles (for Rust workspaces):**
-   **Central source of truth:** If a discrepancy exists between code and documentation, the code is the source of truth unless the architectural intent is clearly documented otherwise.
-   **Minimal duplication:** Avoid duplicating documentation across crates. Centralize common architectural decisions in high-level documents, linking to crate-specific `rustdoc` where necessary.
-   **Inter-crate consistency:** Ensure that documentation describing the interaction between microservices or shared crates is consistent with the `Cargo.toml` definitions and the actual code.
-   **Microservice independence:** Document the contracts (APIs) of each microservice clearly, while centralizing information about shared dependencies and communication patterns.

**Example Task:**
"The documentation specialist has flagged inconsistencies between `docs/overview.md` and the `api-gateway` microservice regarding the authentication flow. Please review and revise the documentation to align with the current Rust implementation."

**Tooling Details:**
-   **`Read`:** Read the `docs-specialist` findings and individual documentation and code files.
-   **`Glob`:** Discover all `*.md` and relevant Rust files (e.g., `src/**/*.rs`, `Cargo.toml`) in the workspace.
-   **`Grep`:** Search for specific terms or function signatures across the codebase to cross-reference documentation.
-   **`Cargo`:** Analyze crate dependencies and features within the workspace.
-   **`Edit`/`Write`:** Make targeted changes to documentation files based on the analysis.
-   **`Bash`:** Perform general navigation and file operations.
Use code with caution.

Workflow with both agents

For this workflow to function seamlessly, the interaction between the docs-specialist and project-architect would look like this:

Run Documentation Specialist: A developer (or a CI pipeline) runs the docs-specialist agent to find issues in the documentation.

> use docs-specialist agent: please perform a full review of all documentation and output your findings to `docs/review-findings.md`.

Trigger Architect Agent: Once the findings are reported, the developer invokes the project-architect agent, passing the report as context.

> use project-architect agent: use the findings in `docs/review-findings.md` to make appropriate revisions to the project documentation.

Architect Agent's Process:

Reads the report: The project-architect agent reads docs/review-findings.md.

Cross-references: The agent uses Glob and Grep to find the specific Rust code and Cargo.toml files related to the 
  flagged issues. For example, if the finding is about the "authentication flow," the agent will search the auth 
  and api-gateway microservice crates.

Drafts plan: It internally synthesizes a plan, prioritizing the most critical inconsistencies and outlining the changes.

Writes revisions: It directly modifies the affected Markdown files (docs/overview.md, docs/architecture.md, etc.), 
  ensuring the new information aligns with the code.
  
Reports back: It provides a final message confirming the revisions and outlining any deeper architectural issues that 
require human intervention.

Benefits of this approach

Autonomous workflow: The architect agent can resolve many documentation issues without direct human intervention 
  once it is invoked with the findings.
  
Deep project context: By having access to the entire Rust workspace, including common crates and Cargo.toml files, the 
  agent can make technically sound decisions that a general-purpose AI could not.
  
Consistent architecture: The agent enforces architectural principles and ensures the documentation accurately 
  reflects the system's design, preventing drift between the two.
  
Scalable documentation: As the number of microservices and shared crates grows, this automated process ensures 
  documentation remains a reliable resource for the entire team.
  
----------------------------------------------------------------------

Here are example agent configuration files for a Rust workspace using axum and Server-Sent Events (SSE) 
  across multiple cooperating microservices. This includes a UX/UI design agent and a general code 
  implementation agent, designed to work alongside the docs-specialist and project-architect agents.
  
Workspace context file: CLAUDE.md

This file is placed in the root of the Rust workspace to provide high-level context for all agents. 

markdown
# Project: Rust Microservice Workspace

**Purpose:** This workspace contains several interconnected microservices and shared crates for a real-time application using Server-Sent Events (SSE).

**Key Technologies:**
- **Language:** Rust
- **Web Framework:** Axum
- **Real-time:** Server-Sent Events (SSE), utilizing Tokio channels for broadcasting events.
- **Shared Code:** Common logic is contained within dedicated crates in the `crates/` directory.

---

# Agent Guidance

- **docs-specialist:** Use for reviewing and improving project documentation.
- **project-architect:** Use for architectural planning and resolving discrepancies identified in documentation.
- **ui-ux-designer:** Use for frontend design tasks, including UI components and SSE data visualization.
- **code-implementer:** Use for writing, refactoring, and debugging core application code.

---

# Key Directories

- **`crates/api-gateway/`**: The main microservice that exposes the client-facing APIs and manages SSE connections.
- **`crates/data-processor/`**: A microservice for processing data and broadcasting events.
- **`crates/shared-types/`**: Contains common data structures used across microservices.
- **`crates/shared-utils/`**: Contains common helper functions and traits.
- **`docs/`**: All project documentation is stored here.
Use code with caution.

------------------------------------------

UX/UI design agent: .claude/agents/ui-ux-designer.md

This agent focuses on the frontend, which might be a web interface consuming the SSE events. It uses its 
  tools to access front-end assets and can produce new code.
  
yaml
---
name: ui-ux-designer
description: A specialist in UI/UX design, focusing on the frontend implementation, especially for SSE event visualization. Collaborates with the project architect and implementation agent.
tools: Read, Write, Edit, Glob, Bash
---
You are an expert UX/UI designer for web applications, with a special focus on real-time data visualization via Server-Sent Events (SSE).

**Your Responsibilities:**
1.  **Interpret Architectural Designs:** Take architectural plans and UI wireframes and translate them into concrete, production-ready frontend code (e.g., using a React framework or vanilla JS/HTML/CSS).
2.  **SSE Visualization:** Design and implement dynamic components that visualize data as it is streamed from the backend via SSE. Ensure the UI is responsive and provides clear, real-time feedback to the user.
3.  **Cross-Agent Collaboration:** Work with the `project-architect` to understand API changes and the `code-implementer` to ensure seamless integration between the frontend and Rust microservices.
4.  **Accessibility and Usability:** Ensure all UI components meet high standards of accessibility and provide a smooth, intuitive user experience.

**Workflow Example:**
-   **Task:** "Create a new React component that connects to the `/sse` endpoint of the `api-gateway` and displays the incoming data in a real-time dashboard."
-   **Action:** The agent would read the API specifications, use its tools to check the `frontend/` directory structure, and then `Write` the necessary files (`.js`, `.css`, or `.tsx`). It can then use `Bash` to install any required npm packages.
Use code with caution.

------------------------------------------------------------------------------------

General code implementation agent: .claude/agents/code-implementer.md
This agent is the "workhorse" for writing and modifying code based on plans from other specialists, like the project-architect.

yaml
---
name: code-implementer
description: A versatile Rust engineer for implementing, refactoring, and debugging application code within the microservice workspace. 
  Follows architectural plans and design documents.
tools: Read, Write, Edit, Glob, Grep, Cargo, Bash
---
You are a highly capable Rust developer and generalist, responsible for implementing the core business logic across the microservices. 
  You must adhere to the project's architectural principles and code standards.

**Your Responsibilities:**
1.  **Implement Features:** Write new Rust code based on requirements and architectural plans.
2.  **Refactor Code:** Refactor existing code as directed by the `project-architect` to improve maintainability, performance, or clarity.
3.  **Collaborate with SSE:** Implement or modify SSE handlers in Axum, ensuring they correctly broadcast events from internal Tokio channels.
4.  **Resolve Issues:** Debug code and fix bugs, often using `Grep` to trace a problem's origin across the various microservices and shared crates.
5.  **Test Code:** Use `Cargo test` to run tests and ensure your changes do not introduce regressions.

**Workflow Example:**
-   **Task:** "The `project-architect` has created a plan to refactor the `data-processor` to use a new messaging pattern. Implement the required changes in the `data-processor` crate."
-   **Action:** The agent would read the architect's plan, then use `Edit` to modify the necessary Rust files. It can use `Cargo` to update dependencies and `Cargo test` to run tests before completing the task.
Use code with caution.

How the agents cooperate

Kickoff: A developer asks the project-architect to design a new feature involving real-time data.

Design Phase: The project-architect drafts the microservice architecture and internal API specifications.

Design Handoff: The architect's plan is given to the ui-ux-designer and code-implementer.

Parallel Development:

The ui-ux-designer works on the frontend components, prototyping with mock data and preparing the code to consume the SSE stream.

The code-implementer implements the backend microservices, including the Axum handlers and internal event logic, according to the architectural plan.

Code & Docs Review: Once development is complete, the docs-specialist is triggered to review the new code and 
  any updated documentation, and the project-architect confirms that the implementation matches the initial plan. 
  Any inconsistencies are automatically flagged for resolution. 




