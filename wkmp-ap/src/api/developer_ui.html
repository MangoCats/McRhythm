<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WKMP Audio Player - Developer UI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 8px;
            line-height: 1.4;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        h1 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header-center {
            flex: 1;
            text-align: center;
            color: #888;
            font-size: 16px;
        }
        .header-right {
            color: #666;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            text-align: right;
        }
        .grid {
            display: grid;
            grid-template-columns: auto auto 1fr;
            gap: 8px;
            flex: 1;
            overflow: hidden;
        }
        .panel {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        h2 {
            color: #4a9eff;
            font-size: 16px;
            margin-bottom: 6px;
            border-bottom: 1px solid #3a3a3a;
            padding-bottom: 4px;
        }
        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .status-item:last-child { border-bottom: none; }
        .status-label { color: #888; font-size: 13px; }
        .status-value { color: #e0e0e0; font-weight: 500; font-size: 13px; }
        .state-playing { color: #4ade80; }
        .state-paused { color: #fbbf24; }
        .queue-item {
            background: #333;
            padding: 6px;
            margin: 4px 0;
            border-radius: 3px;
            font-size: 12px;
        }
        .queue-item-id { color: #888; font-size: 10px; }
        .queue-empty { color: #666; font-style: italic; padding: 6px 0; }
        .control-group { margin-bottom: 6px; }
        .control-group label {
            display: block;
            color: #888;
            font-size: 12px;
            margin-bottom: 3px;
        }
        input, select, button {
            width: 100%;
            padding: 6px 8px;
            background: #333;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 3px;
            font-size: 13px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        button {
            cursor: pointer;
            background: #4a9eff;
            border: none;
            font-weight: 600;
            transition: background 0.2s;
            margin-top: 3px;
        }
        button:hover { background: #3a8eef; }
        button:active { background: #2a7edf; }
        .button-group { display: flex; gap: 4px; }
        .button-group button { flex: 1; }
        .btn-play { background: #4ade80; }
        .btn-play:hover { background: #3ace70; }
        .btn-pause { background: #fbbf24; }
        .btn-pause:hover { background: #eaaf14; }
        .btn-skip { background: #f97316; }
        .btn-skip:hover { background: #e96306; }
        .btn-danger { background: #dc2626; }
        .btn-danger:hover { background: #cc1616; }
        .event-log {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 6px;
            flex: 1;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .event-item {
            padding: 3px;
            border-bottom: 1px solid #2a2a2a;
            word-break: break-all;
        }
        .event-item:last-child { border-bottom: none; }
        .event-time { color: #666; }
        .event-type { font-weight: 600; }
        .event-data { color: #888; }

        /* Event type colors */
        .event-type-InitialState { color: #8b5cf6; }
        .event-type-QueueStateUpdate { color: #3b82f6; }
        .event-type-PlaybackPosition { color: #10b981; }
        .event-type-VolumeChanged { color: #f59e0b; }
        .event-type-PlaybackStateChanged { color: #ef4444; }
        .event-type-CrossfadeStarted { color: #ec4899; }
        .event-type-PassageStarted { color: #06b6d4; }
        .event-type-PassageCompleted { color: #84cc16; }
        .event-type-system { color: #6b7280; }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 3px;
        }
        .progress-fill {
            height: 100%;
            background: #4a9eff;
            transition: width 0.3s;
        }
        .error { color: #f87171; font-size: 12px; margin-top: 3px; }
        .success { color: #4ade80; font-size: 12px; margin-top: 3px; }

        .connection-status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 6px;
        }
        .status-connected {
            background: #10b981;
            color: #fff;
        }
        .status-connecting {
            background: #f59e0b;
            color: #fff;
        }
        .status-disconnected {
            background: #ef4444;
            color: #fff;
        }

        .event-controls {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
        }
        .event-controls button {
            flex: 1;
            margin-top: 0;
            padding: 6px;
            font-size: 12px;
        }

        /* 12-Chain Buffer Monitor Styles */
        .buffer-monitor {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .buffer-detailed {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .buffer-chain-full {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            border-left: 4px solid;
        }
        .buffer-chain-full.pos-1 { border-left-color: #4ade80; }
        .buffer-chain-full.pos-2 { border-left-color: #fbbf24; }
        .chain-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #2a2a2a;
        }
        .chain-title {
            font-weight: bold;
            font-size: 13px;
        }
        .chain-title.pos-1 { color: #4ade80; }
        .chain-title.pos-2 { color: #fbbf24; }
        .chain-filename {
            color: #888;
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 400px;
        }
        .chain-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 11px;
        }
        .metric {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .metric-label {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
        }
        .metric-value {
            color: #e0e0e0;
            font-weight: 500;
        }
        .buffer-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
        }
        .buffer-chain-compact {
            background: #1a1a1a;
            padding: 6px;
            border-radius: 3px;
            border-left: 3px solid;
            font-size: 10px;
        }
        .buffer-chain-compact.queued { border-left-color: #3b82f6; }
        .buffer-chain-compact.idle { border-left-color: #444; }
        .compact-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        .compact-row:last-child { margin-bottom: 0; }
        .compact-label { color: #666; }
        .compact-value { color: #e0e0e0; font-weight: 500; }
        .buffer-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }
        .buffer-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .buffer-bar-fill.filling { background: #3b82f6; }
        .buffer-bar-fill.ready { background: #10b981; }
        .buffer-bar-fill.playing { background: #4ade80; }
        .state-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .state-Empty { background: #444; color: #888; }
        .state-Filling { background: #3b82f6; color: #fff; }
        .state-Ready { background: #10b981; color: #fff; }
        .state-Playing { background: #4ade80; color: #000; }
        .state-Finished { background: #666; color: #ccc; }
        .decoder-state {
            color: #888;
            font-size: 10px;
        }
        .decoder-Idle { color: #666; }
        .decoder-Decoding { color: #3b82f6; }
        .decoder-Paused { color: #fbbf24; }

        /* File Browser Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.open { display: flex; }
        .modal-content {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 10px 12px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h3 {
            color: #4a9eff;
            margin: 0;
            font-size: 16px;
        }
        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: auto;
            margin: 0;
        }
        .modal-close:hover { color: #e0e0e0; }
        .modal-body {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }
        .current-path {
            background: #1a1a1a;
            padding: 6px;
            border-radius: 3px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #888;
            word-break: break-all;
        }
        .file-list {
            border: 1px solid #333;
            border-radius: 3px;
            max-height: 400px;
            overflow-y: auto;
        }
        .file-item {
            padding: 6px 8px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s;
        }
        .file-item:last-child { border-bottom: none; }
        .file-item:hover { background: #333; }
        .file-item.selected { background: #4a9eff; color: #fff; }
        .file-icon {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }
        .file-name { flex: 1; font-size: 14px; }
        .btn-browse {
            background: #666;
            margin-top: 0;
            margin-left: 10px;
            width: auto;
            padding: 10px 15px;
        }
        .btn-browse:hover { background: #777; }
        .input-with-browse {
            display: flex;
            align-items: center;
        }
        .input-with-browse input { margin-top: 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            <div class="header-left">
                WKMP Audio Player
                <span class="connection-status" id="connection-status">Connecting...</span>
            </div>
            <div class="header-center">Developer Interface</div>
            <div class="header-right" id="build-info">Loading...</div>
        </h1>

        <div class="grid">
            <!-- Module Status (half-width) -->
            <div class="panel" style="grid-column: span 1;">
                <h2>Module Status</h2>
                <div class="status-item">
                    <span class="status-label">Playback State</span>
                    <span class="status-value" id="playback-state">Waiting for SSE...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Position</span>
                    <span class="status-value" id="position">-</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="status-item">
                    <span class="status-label">Volume</span>
                    <span class="status-value" id="volume">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Audio Device</span>
                    <span class="status-value" id="audio-device">default</span>
                </div>
                <div class="control-group" style="margin-top: 8px;">
                    <label>Change Device</label>
                    <input type="text" id="device-input" placeholder="default">
                    <button onclick="setAudioDevice()">Set Device</button>
                    <div id="device-result"></div>
                </div>
            </div>

            <!-- Playback Controls (half-width) -->
            <div class="panel" style="grid-column: span 1;">
                <h2>Playback Controls</h2>
                <div class="button-group">
                    <button class="btn-play" onclick="controlPlayback('play')">▶ Play</button>
                    <button class="btn-pause" onclick="controlPlayback('pause')">⏸ Pause</button>
                </div>
                <div class="button-group" style="margin-top: 6px;">
                    <button class="btn-skip" onclick="skipCurrentPassage()">⏭ Skip Current</button>
                    <button class="btn-danger" onclick="clearQueue()">🗑 Clear Queue</button>
                </div>
                <div class="control-group" style="margin-top: 8px;">
                    <label>Volume (0 - 100)</label>
                    <input type="number" id="volume-input" min="0" max="100" step="5" value="75">
                    <button onclick="setVolume()">Set Volume</button>
                    <div id="volume-result"></div>
                </div>
            </div>

            <!-- Queue Contents (with Enqueue controls) -->
            <div class="panel">
                <h2>Queue Contents</h2>
                <div id="queue-display" style="margin-bottom: 8px;">Waiting for SSE...</div>
                <div class="control-group" style="border-top: 1px solid #3a3a3a; padding-top: 8px; margin-top: 8px;">
                    <label>Enqueue Passage</label>
                    <div class="input-with-browse">
                        <input type="text" id="file-path" placeholder="/path/to/audio/file.mp3">
                        <button class="btn-browse" onclick="openFileBrowser()">Browse</button>
                    </div>
                    <button onclick="enqueuePassage()">Enqueue</button>
                    <div id="enqueue-result"></div>
                </div>
            </div>

            <!-- Buffer Chain Monitor -->
            <div class="panel" style="grid-column: 1 / -1;">
                <h2>Buffer Chain Monitor</h2>
                <div id="buffer-chains" style="font-family: 'Courier New', monospace; font-size: 12px;">
                    <div style="color: #888;">Waiting for buffer chain data...</div>
                </div>
            </div>

            <!-- Event Stream Monitor -->
            <div class="panel" style="grid-column: 1 / -1;">
                <h2>Event Stream Monitor (SSE)</h2>
                <div class="event-controls">
                    <button onclick="clearEventLog()">Clear Log</button>
                    <button onclick="exportEventLog()">Export JSON</button>
                    <button onclick="toggleEventPause()">
                        <span id="pause-text">Pause</span>
                    </button>
                </div>
                <div class="event-log" id="event-log">
                    <div class="event-item">Connecting to event stream...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- File Browser Modal -->
    <div class="modal" id="file-browser-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Browse Audio Files</h3>
                <button class="modal-close" onclick="closeFileBrowser()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="current-path" id="current-path-display">Loading...</div>
                <div class="file-list" id="file-list">
                    <div class="file-item">Loading files...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = '';
        let eventSource = null;
        const maxEvents = 100;
        const eventHistory = []; // Store all events for export
        let eventsPaused = false;

        // Fetch initial state from API
        async function fetchInitialState() {
            try {
                // Fetch build info
                const buildResponse = await fetch(`${API_BASE}/build_info`);
                if (buildResponse.ok) {
                    const buildData = await buildResponse.json();
                    const buildInfo = `v${buildData.version} [${buildData.git_hash}] ${buildData.build_timestamp} (${buildData.build_profile})`;
                    document.getElementById('build-info').textContent = buildInfo;
                }

                // Fetch playback state
                const stateResponse = await fetch(`${API_BASE}/playback/state`);
                if (stateResponse.ok) {
                    const stateData = await stateResponse.json();
                    updatePlaybackState(stateData.state);
                }

                // Fetch queue
                const queueResponse = await fetch(`${API_BASE}/playback/queue`);
                if (queueResponse.ok) {
                    const queueData = await queueResponse.json();
                    updateQueueDisplay(queueData.queue);
                }

                // Fetch position
                const positionResponse = await fetch(`${API_BASE}/playback/position`);
                if (positionResponse.ok) {
                    const positionData = await positionResponse.json();
                    updatePosition(positionData);
                }

                // Fetch volume
                const volumeResponse = await fetch(`${API_BASE}/audio/volume`);
                if (volumeResponse.ok) {
                    const volumeData = await volumeResponse.json();
                    updateVolumeDisplay(volumeData.volume);
                }

                // Fetch buffer chains
                const bufferResponse = await fetch(`${API_BASE}/playback/buffer_chains`);
                if (bufferResponse.ok) {
                    const bufferData = await bufferResponse.json();
                    updateBufferChainDisplay(bufferData.chains);
                }
            } catch (err) {
                console.error('Failed to fetch initial state:', err);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            fetchInitialState();
            connectEventStream();
        });

        // Connect to SSE event stream with auto-reconnect
        function connectEventStream() {
            const logEl = document.getElementById('event-log');
            const statusEl = document.getElementById('connection-status');

            if (eventSource) {
                eventSource.close();
            }

            updateConnectionStatus('connecting');
            eventSource = new EventSource(`${API_BASE}/events`);

            eventSource.onopen = () => {
                updateConnectionStatus('connected');
                addEvent('system', 'Connected to SSE event stream');
            };

            eventSource.onerror = (err) => {
                updateConnectionStatus('disconnected');
                addEvent('system', 'SSE connection error, auto-reconnecting...');
                // EventSource automatically reconnects
            };

            // Handle all event types
            eventSource.addEventListener('InitialState', (e) => {
                handleInitialState(JSON.parse(e.data));
            });

            eventSource.addEventListener('QueueStateUpdate', (e) => {
                handleQueueStateUpdate(JSON.parse(e.data));
            });

            eventSource.addEventListener('PlaybackPosition', (e) => {
                handlePlaybackPosition(JSON.parse(e.data));
            });

            eventSource.addEventListener('VolumeChanged', (e) => {
                handleVolumeChanged(JSON.parse(e.data));
            });

            eventSource.addEventListener('PlaybackStateChanged', (e) => {
                handlePlaybackStateChanged(JSON.parse(e.data));
            });

            eventSource.addEventListener('CrossfadeStarted', (e) => {
                handleCrossfadeStarted(JSON.parse(e.data));
            });

            eventSource.addEventListener('PassageStarted', (e) => {
                handlePassageStarted(JSON.parse(e.data));
            });

            eventSource.addEventListener('PassageCompleted', (e) => {
                handlePassageCompleted(JSON.parse(e.data));
            });

            eventSource.addEventListener('BufferChainStatus', (e) => {
                handleBufferChainStatus(JSON.parse(e.data));
            });

            // Fallback for unknown events
            eventSource.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    addEvent(data.type || 'unknown', JSON.stringify(data, null, 2));
                } catch (err) {
                    addEvent('raw', e.data);
                }
            };
        }

        // SSE Event Handlers
        function handleInitialState(data) {
            addEvent('InitialState', JSON.stringify(data, null, 2));

            // Update queue
            if (data.queue) {
                updateQueueDisplay(data.queue);
            }

            // Update position
            if (data.position) {
                updatePosition(data.position);
            }

            // Update volume
            if (typeof data.volume === 'number') {
                updateVolumeDisplay(data.volume);
            }
        }

        function handleQueueStateUpdate(data) {
            addEvent('QueueStateUpdate', `Queue updated: ${data.queue.length} entries`);
            updateQueueDisplay(data.queue);
        }

        function handlePlaybackPosition(data) {
            // Don't log every position update (too spammy), just update UI
            updatePosition({
                passage_id: data.passage_id,
                position_ms: data.position_ms,
                duration_ms: data.duration_ms,
                playing: data.playing
            });
        }

        function handleVolumeChanged(data) {
            addEvent('VolumeChanged', `Volume: ${Math.round(data.volume * 100)}%`);
            updateVolumeDisplay(data.volume);
        }

        function handlePlaybackStateChanged(data) {
            addEvent('PlaybackStateChanged', `State: ${data.state}`);
            updatePlaybackState(data.state);
        }

        function handleCrossfadeStarted(data) {
            addEvent('CrossfadeStarted', `From: ${data.from_passage_id.substring(0, 8)}... To: ${data.to_passage_id.substring(0, 8)}...`);
        }

        function handlePassageStarted(data) {
            addEvent('PassageStarted', `Passage: ${data.passage_id.substring(0, 8)}...`);
        }

        function handlePassageCompleted(data) {
            const status = data.completed ? 'completed' : 'skipped';
            addEvent('PassageCompleted', `Passage: ${data.passage_id.substring(0, 8)}... (${status})`);
        }

        function handleBufferChainStatus(data) {
            // Don't add to event log (too noisy)
            updateBufferChainDisplay(data.chains);
        }

        // UI Update Functions
        function updateQueueDisplay(queue) {
            const queueEl = document.getElementById('queue-display');

            if (!queue || queue.length === 0) {
                queueEl.innerHTML = '<div class="queue-empty">Queue is empty</div>';
                return;
            }

            queueEl.innerHTML = queue.map(item => `
                <div class="queue-item">
                    <div>${item.file_path || 'Unknown'}</div>
                    <div class="queue-item-id">ID: ${item.queue_entry_id || 'N/A'}</div>
                </div>
            `).join('');
        }

        function updatePosition(position) {
            if (!position) {
                document.getElementById('position').textContent = '-';
                document.getElementById('progress-fill').style.width = '0%';
                return;
            }

            const posMs = position.position_ms || 0;
            const durMs = position.duration_ms || 1;
            const posSec = Math.floor(posMs / 1000);
            const durSec = Math.floor(durMs / 1000);

            document.getElementById('position').textContent = `${formatTime(posSec)} / ${formatTime(durSec)}`;

            const progress = durMs > 0 ? (posMs / durMs * 100) : 0;
            document.getElementById('progress-fill').style.width = progress + '%';
        }

        function updateBufferChainDisplay(chains) {
            const el = document.getElementById('buffer-chains');
            if (!chains || chains.length === 0) {
                el.innerHTML = '<div style="color: #888;">No buffer chains</div>';
                return;
            }

            // Ensure we display all 12 chains, filling in missing ones as idle
            const allChains = [];
            for (let i = 0; i < 12; i++) {
                const existingChain = chains.find(c => c.slot_index === i);
                if (existingChain) {
                    allChains.push(existingChain);
                } else {
                    // Create idle placeholder
                    allChains.push({
                        slot_index: i,
                        queue_position: null,
                        buffer_state: 'Empty',
                        buffer_fill_percent: 0,
                        buffer_fill_samples: 0,
                        buffer_capacity_samples: 0,
                        mixer_role: 'Idle',
                        is_active_in_mixer: false,
                        file_name: null,
                        passage_id: null,
                        playback_position_ms: 0,
                        duration_ms: 0
                    });
                }
            }

            // Sort by queue_position to ensure proper ordering
            allChains.sort((a, b) => {
                if (a.queue_position && b.queue_position) {
                    return a.queue_position - b.queue_position;
                }
                if (a.queue_position) return -1;
                if (b.queue_position) return 1;
                return a.slot_index - b.slot_index;
            });

            let html = '<div class="buffer-monitor">';

            // Detailed view for positions 1-2 (now playing and next)
            const detailedChains = allChains.filter(c => c.queue_position === 1 || c.queue_position === 2);
            if (detailedChains.length > 0) {
                html += '<div class="buffer-detailed">';
                detailedChains.forEach(chain => {
                    html += renderChainFull(chain);
                });
                html += '</div>';
            }

            // Compact grid for positions 3-12 and idle chains
            const compactChains = allChains.filter(c => !c.queue_position || c.queue_position > 2);
            if (compactChains.length > 0) {
                html += '<div class="buffer-grid">';
                compactChains.forEach(chain => {
                    html += renderChainCompact(chain);
                });
                html += '</div>';
            }

            html += '</div>';
            el.innerHTML = html;
        }

        function renderChainFull(chain) {
            const queuePos = chain.queue_position || 0;
            const posClass = queuePos === 1 ? 'pos-1' : 'pos-2';
            const fileName = chain.file_name || '(idle)';
            const bufferPct = chain.buffer_fill_percent.toFixed(1);
            const posMs = chain.playback_position_ms || 0;
            const posSec = Math.floor(posMs / 1000);
            const durMs = chain.duration_ms || 0;
            const durSec = Math.floor(durMs / 1000);
            const bufferState = chain.buffer_state || 'Empty';
            const decoderState = chain.decoder_state || 'N/A';
            const fadeStage = chain.fade_stage || 'N/A';
            const decodeProgress = chain.decode_progress_percent || 0;

            const title = queuePos === 1 ? 'NOW PLAYING (Position 1)' : 'UP NEXT (Position 2)';

            return `
                <div class="buffer-chain-full ${posClass}">
                    <div class="chain-header">
                        <div>
                            <div class="chain-title ${posClass}">${title}</div>
                            <div class="chain-filename" title="${escapeHtml(fileName)}">${escapeHtml(fileName)}</div>
                        </div>
                        <span class="state-badge state-${bufferState}">${bufferState}</span>
                    </div>
                    <div class="chain-metrics">
                        <div class="metric">
                            <div class="metric-label">Queue Position</div>
                            <div class="metric-value" style="color: ${queuePos === 1 ? '#4ade80' : '#fbbf24'}; font-size: 18px;">
                                #${queuePos}
                            </div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Buffer Fill</div>
                            <div class="metric-value">${bufferPct}%</div>
                            <div style="color: #666; font-size: 9px;">${formatNumber(chain.buffer_fill_samples)} / ${formatNumber(chain.buffer_capacity_samples)} samples</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Playback Position</div>
                            <div class="metric-value">${formatTime(posSec)} / ${formatTime(durSec)}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Decoder State</div>
                            <div class="metric-value decoder-state decoder-${decoderState}">${decoderState}</div>
                            <div style="color: #666; font-size: 9px;">Progress: ${decodeProgress}%</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Fade Stage</div>
                            <div class="metric-value">${fadeStage}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Mixer Role</div>
                            <div class="metric-value">${chain.mixer_role}</div>
                            <div style="color: ${chain.is_active_in_mixer ? '#4ade80' : '#666'}; font-size: 9px;">
                                ${chain.is_active_in_mixer ? '✓ Active' : '○ Inactive'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderChainCompact(chain) {
            const queuePos = chain.queue_position;
            const isIdle = !queuePos;
            const bufferState = chain.buffer_state || 'Empty';
            const bufferPct = chain.buffer_fill_percent.toFixed(0);
            const passageId = chain.passage_id ? chain.passage_id.substring(0, 8) : 'N/A';

            const stateClass = bufferState.toLowerCase();
            const borderClass = isIdle ? 'idle' : 'queued';

            let statusColor = '#666';
            if (bufferState === 'Playing') statusColor = '#4ade80';
            else if (bufferState === 'Ready') statusColor = '#10b981';
            else if (bufferState === 'Filling') statusColor = '#3b82f6';

            return `
                <div class="buffer-chain-compact ${borderClass}">
                    <div class="compact-row">
                        <span class="compact-label">Slot ${chain.slot_index}</span>
                        <span class="compact-value" style="color: ${queuePos ? '#4a9eff' : '#666'};">
                            ${queuePos ? 'Pos ' + queuePos : 'Idle'}
                        </span>
                    </div>
                    <div class="compact-row">
                        <span class="compact-label">Passage</span>
                        <span class="compact-value" style="font-size: 9px;">${passageId}</span>
                    </div>
                    <div class="compact-row">
                        <span class="compact-label">State</span>
                        <span class="compact-value" style="color: ${statusColor};">${bufferState}</span>
                    </div>
                    <div class="compact-row">
                        <span class="compact-label">Buffer</span>
                        <span class="compact-value">${bufferPct}%</span>
                    </div>
                    <div class="buffer-bar">
                        <div class="buffer-bar-fill ${stateClass}" style="width: ${bufferPct}%;"></div>
                    </div>
                </div>
            `;
        }

        function formatNumber(num) {
            return num.toLocaleString();
        }

        function updateVolumeDisplay(volume) {
            document.getElementById('volume').textContent = Math.round(volume * 100) + '%';
            document.getElementById('volume-input').value = Math.round(volume * 100);
        }

        function updatePlaybackState(state) {
            const stateEl = document.getElementById('playback-state');
            stateEl.textContent = state;
            stateEl.className = 'status-value ' + (state === 'playing' ? 'state-playing' : 'state-paused');
        }

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connection-status');
            statusEl.className = 'connection-status status-' + status;
            statusEl.textContent = status === 'connected' ? 'Connected' :
                                  status === 'connecting' ? 'Connecting...' : 'Disconnected';
        }

        // Event Log Functions
        function addEvent(type, data) {
            if (eventsPaused) return;

            const logEl = document.getElementById('event-log');
            const time = new Date().toLocaleTimeString();
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event-item';
            eventDiv.innerHTML = `
                <span class="event-time">[${time}]</span>
                <span class="event-type event-type-${escapeHtml(type)}">${escapeHtml(type)}</span>:
                <span class="event-data">${escapeHtml(data)}</span>
            `;
            logEl.insertBefore(eventDiv, logEl.firstChild);

            // Store in history
            eventHistory.unshift({ time, type, data });

            // Keep only last N events in DOM
            while (logEl.children.length > maxEvents) {
                logEl.removeChild(logEl.lastChild);
            }

            // Keep only last N*2 events in history
            if (eventHistory.length > maxEvents * 2) {
                eventHistory.length = maxEvents * 2;
            }
        }

        function clearEventLog() {
            document.getElementById('event-log').innerHTML = '';
            eventHistory.length = 0;
            addEvent('system', 'Event log cleared');
        }

        function exportEventLog() {
            const dataStr = JSON.stringify(eventHistory, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `wkmp-events-${new Date().toISOString()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            addEvent('system', 'Event log exported');
        }

        function toggleEventPause() {
            eventsPaused = !eventsPaused;
            document.getElementById('pause-text').textContent = eventsPaused ? 'Resume' : 'Pause';
            addEvent('system', eventsPaused ? 'Event logging paused' : 'Event logging resumed');
        }

        // Playback control
        async function controlPlayback(action) {
            try {
                const response = await fetch(`${API_BASE}/playback/${action}`, { method: 'POST' });
                if (!response.ok) {
                    console.error(`Failed to ${action}`);
                }
            } catch (err) {
                console.error(`Failed to ${action}:`, err);
            }
        }

        // Skip current passage
        async function skipCurrentPassage() {
            try {
                const response = await fetch(`${API_BASE}/playback/next`, { method: 'POST' });
                if (!response.ok) {
                    console.error('Failed to skip passage');
                }
            } catch (err) {
                console.error('Failed to skip passage:', err);
            }
        }

        // Clear entire queue
        async function clearQueue() {
            if (!confirm('Clear entire queue? This will remove all passages.')) {
                return;
            }
            try {
                const response = await fetch(`${API_BASE}/playback/queue/clear`, { method: 'POST' });
                if (!response.ok) {
                    console.error('Failed to clear queue');
                }
            } catch (err) {
                console.error('Failed to clear queue:', err);
            }
        }

        // Set volume
        async function setVolume() {
            const resultEl = document.getElementById('volume-result');
            try {
                const userVolume = parseInt(document.getElementById('volume-input').value);
                const apiVolume = userVolume / 100.0;
                const response = await fetch(`${API_BASE}/audio/volume`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ volume: apiVolume })
                });
                if (response.ok) {
                    resultEl.innerHTML = '<div class="success">✓ Volume set</div>';
                } else {
                    resultEl.innerHTML = '<div class="error">✗ Failed</div>';
                }
            } catch (err) {
                resultEl.innerHTML = '<div class="error">✗ Error: ' + err.message + '</div>';
            }
            setTimeout(() => resultEl.innerHTML = '', 3000);
        }

        // Set audio device
        async function setAudioDevice() {
            const resultEl = document.getElementById('device-result');
            try {
                const device = document.getElementById('device-input').value;
                const response = await fetch(`${API_BASE}/audio/device`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device })
                });
                if (response.ok) {
                    resultEl.innerHTML = '<div class="success">✓ Device set</div>';
                } else {
                    resultEl.innerHTML = '<div class="error">✗ Failed</div>';
                }
            } catch (err) {
                resultEl.innerHTML = '<div class="error">✗ Error: ' + err.message + '</div>';
            }
            setTimeout(() => resultEl.innerHTML = '', 3000);
        }

        // Enqueue passage
        async function enqueuePassage() {
            const resultEl = document.getElementById('enqueue-result');
            try {
                const filePath = document.getElementById('file-path').value;
                if (!filePath) {
                    resultEl.innerHTML = '<div class="error">✗ Enter a file path</div>';
                    return;
                }
                const response = await fetch(`${API_BASE}/playback/enqueue`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_path: filePath })
                });
                if (response.ok) {
                    resultEl.innerHTML = '<div class="success">✓ Enqueued</div>';
                } else {
                    const error = await response.text();
                    resultEl.innerHTML = '<div class="error">✗ ' + error + '</div>';
                }
            } catch (err) {
                resultEl.innerHTML = '<div class="error">✗ Error: ' + err.message + '</div>';
            }
            setTimeout(() => resultEl.innerHTML = '', 3000);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // File Browser Functions
        let currentBrowserPath = null;
        let selectedFilePath = null;

        async function openFileBrowser() {
            const modal = document.getElementById('file-browser-modal');
            modal.classList.add('open');
            await loadDirectory();
        }

        function closeFileBrowser() {
            const modal = document.getElementById('file-browser-modal');
            modal.classList.remove('open');
            selectedFilePath = null;
        }

        async function loadDirectory(path = null) {
            const pathDisplay = document.getElementById('current-path-display');
            const fileList = document.getElementById('file-list');

            try {
                const url = path
                    ? `${API_BASE}/files/browse?path=${encodeURIComponent(path)}`
                    : `${API_BASE}/files/browse`;

                const response = await fetch(url);
                if (!response.ok) {
                    const error = await response.json();
                    fileList.innerHTML = `<div class="file-item" style="color: #f87171;">Error: ${error.status || 'Failed to load directory'}</div>`;
                    return;
                }

                const data = await response.json();
                currentBrowserPath = data.current_path;
                pathDisplay.textContent = data.current_path;

                if (data.entries.length === 0) {
                    fileList.innerHTML = '<div class="file-item" style="color: #888;">No files or directories found</div>';
                    return;
                }

                let html = '';

                if (data.parent_path) {
                    html += `
                        <div class="file-item" data-path="${escapeHtml(data.parent_path)}" data-action="directory">
                            <span class="file-icon">📁</span>
                            <span class="file-name">..</span>
                        </div>
                    `;
                }

                data.entries.forEach(entry => {
                    const icon = entry.is_directory ? '📁' : '🎵';
                    const action = entry.is_directory ? 'directory' : 'file';
                    const color = entry.is_audio_file ? '#4ade80' : '#e0e0e0';

                    html += `
                        <div class="file-item" data-path="${escapeHtml(entry.path)}" data-action="${action}">
                            <span class="file-icon">${icon}</span>
                            <span class="file-name" style="color: ${color};">${escapeHtml(entry.name)}</span>
                        </div>
                    `;
                });

                fileList.innerHTML = html;

                fileList.querySelectorAll('.file-item[data-path]').forEach(item => {
                    item.addEventListener('click', () => {
                        const path = item.getAttribute('data-path');
                        const action = item.getAttribute('data-action');
                        if (action === 'directory') {
                            loadDirectory(path);
                        } else {
                            selectFile(path);
                        }
                    });
                });
            } catch (err) {
                fileList.innerHTML = `<div class="file-item" style="color: #f87171;">Error: ${err.message}</div>`;
            }
        }

        function selectFile(path) {
            document.getElementById('file-path').value = path;
            selectedFilePath = path;
            closeFileBrowser();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
