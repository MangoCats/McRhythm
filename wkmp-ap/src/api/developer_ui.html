<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WKMP Audio Player - Developer UI</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 8px;
            line-height: 1.4;
            min-height: 100vh;
            overflow-y: auto;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        h1 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .header-center {
            flex: 1;
            text-align: center;
            color: #888;
            font-size: 16px;
        }
        .header-right {
            color: #666;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            text-align: right;
        }
        .grid {
            display: grid;
            grid-template-columns: auto auto 1fr;
            gap: 8px;
        }
        .panel {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #queue-display {
            max-height: 400px;
            overflow-y: auto;
        }
        h2 {
            color: #4a9eff;
            font-size: 16px;
            margin-bottom: 6px;
            border-bottom: 1px solid #3a3a3a;
            padding-bottom: 4px;
        }
        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .status-item:last-child { border-bottom: none; }
        .status-label { color: #888; font-size: 13px; }
        .status-value { color: #e0e0e0; font-weight: 500; font-size: 13px; }
        .state-playing { color: #4ade80; }
        .state-paused { color: #fbbf24; }
        .queue-item {
            background: #333;
            padding: 6px;
            margin: 4px 0;
            border-radius: 3px;
            font-size: 12px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .queue-item-content {
            flex: 1;
            min-width: 0;
        }
        .queue-item-id { color: #888; font-size: 10px; }
        .queue-item-remove {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            padding: 0;
            margin: 0;
            background: #dc2626;
            border: none;
            border-radius: 3px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .queue-item-remove:hover {
            background: #b91c1c;
        }
        .queue-item-remove:active {
            background: #991b1b;
        }
        .queue-empty { color: #666; font-style: italic; padding: 6px 0; }
        .control-group { margin-bottom: 6px; }
        .control-group label {
            display: block;
            color: #888;
            font-size: 12px;
            margin-bottom: 3px;
        }
        input, select, button {
            width: 100%;
            padding: 6px 8px;
            background: #333;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 3px;
            font-size: 13px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #4a9eff;
        }
        button {
            cursor: pointer;
            background: #4a9eff;
            border: none;
            font-weight: 600;
            transition: background 0.2s;
            margin-top: 3px;
        }
        button:hover { background: #3a8eef; }
        button:active { background: #2a7edf; }
        .button-group { display: flex; gap: 4px; }
        .button-group button { flex: 1; }
        .btn-play { background: #4ade80; }
        .btn-play:hover { background: #3ace70; }
        .btn-pause { background: #fbbf24; }
        .btn-pause:hover { background: #eaaf14; }
        .btn-skip { background: #f97316; }
        .btn-skip:hover { background: #e96306; }
        .btn-danger { background: #dc2626; }
        .btn-danger:hover { background: #cc1616; }
        .event-log {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 3px;
            padding: 6px;
            max-height: 600px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .event-item {
            padding: 3px;
            border-bottom: 1px solid #2a2a2a;
            word-break: break-all;
        }
        .event-item:last-child { border-bottom: none; }
        .event-time { color: #666; }
        .event-type { font-weight: 600; }
        .event-data { color: #888; }

        /* Event type colors */
        .event-type-InitialState { color: #8b5cf6; }
        .event-type-QueueStateUpdate { color: #3b82f6; }
        .event-type-PlaybackPosition { color: #10b981; }
        .event-type-VolumeChanged { color: #f59e0b; }
        .event-type-PlaybackStateChanged { color: #ef4444; }
        .event-type-CrossfadeStarted { color: #ec4899; }
        .event-type-PassageStarted { color: #06b6d4; }
        .event-type-PassageCompleted { color: #84cc16; }
        .event-type-system { color: #6b7280; }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 3px;
        }
        .progress-fill {
            height: 100%;
            background: #4a9eff;
            transition: width 0.3s;
        }
        .error { color: #f87171; font-size: 12px; margin-top: 3px; }
        .success { color: #4ade80; font-size: 12px; margin-top: 3px; }

        .connection-status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 6px;
        }
        .status-connected {
            background: #10b981;
            color: #fff;
        }
        .status-connecting {
            background: #f59e0b;
            color: #fff;
        }
        .status-disconnected {
            background: #ef4444;
            color: #fff;
        }

        .event-controls {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
        }
        .event-controls button {
            flex: 1;
            margin-top: 0;
            padding: 6px;
            font-size: 12px;
        }

        /* 12-Chain Buffer Monitor Styles */
        .buffer-monitor {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Scrollable container for buffer chain table */
        #buffer-chains {
            overflow-y: auto;
            max-height: 400px;
            border: 1px solid #333;
            border-radius: 3px;
        }
        /* **[SPEC020-MONITOR-020]** Table-based buffer chain monitor */
        .buffer-chain-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        .buffer-chain-table thead {
            background: #1a1a1a;
            position: sticky;
            top: 0;
        }
        .buffer-chain-table th {
            padding: 8px;
            text-align: left;
            color: #888;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
            border-bottom: 2px solid #333;
        }
        .buffer-chain-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #2a2a2a;
        }
        /* **[SPEC020-MONITOR-050]** Row color coding by queue position */
        .chain-row.pos-0 {
            background: rgba(74, 222, 128, 0.1);  /* Green for now playing */
            border-left: 3px solid #4ade80;
        }
        .chain-row.pos-1 {
            background: rgba(251, 191, 36, 0.1);  /* Yellow for up next */
            border-left: 3px solid #fbbf24;
        }
        .chain-row.pos-queued {
            background: rgba(59, 130, 246, 0.05); /* Blue for queued */
            border-left: 3px solid #3b82f6;
        }
        .chain-row.idle {
            background: transparent;
            border-left: 3px solid #444;
        }
        .chain-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        /* Column-specific styles */
        .chain-num {
            color: #888;
            font-weight: 600;
            width: 60px;
        }
        .queue-pos {
            color: #e0e0e0;
            font-weight: 500;
            width: 140px;
        }
        .decoder, .resample, .fade, .mixer {
            color: #e0e0e0;
            font-size: 10px;
        }
        .file-name-cell {
            color: #e0e0e0;
            font-size: 10px;
            max-width: 20%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        /* **[SPEC020-MONITOR-090]** Buffer fill bar */
        .buffer-bar-container {
            position: relative;
            height: 20px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            min-width: 80px;
        }
        .buffer-bar-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: #3b82f6;
            transition: width 0.3s;
        }
        .buffer-text {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 9px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .state-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .state-Empty { background: #444; color: #888; }
        .state-Filling { background: #3b82f6; color: #fff; }
        .state-Ready { background: #10b981; color: #fff; }
        .state-Playing { background: #4ade80; color: #000; }
        .state-Finished { background: #666; color: #ccc; }
        .decoder-state {
            color: #888;
            font-size: 10px;
        }
        .decoder-Idle { color: #666; }
        .decoder-Decoding { color: #3b82f6; }
        .decoder-Paused { color: #fbbf24; }

        /* File Browser Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.open { display: flex; }
        .modal-content {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 10px 12px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h3 {
            color: #4a9eff;
            margin: 0;
            font-size: 16px;
        }
        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: auto;
            margin: 0;
        }
        .modal-close:hover { color: #e0e0e0; }
        .modal-body {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }
        .current-path {
            background: #1a1a1a;
            padding: 6px;
            border-radius: 3px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #888;
            word-break: break-all;
        }
        .file-list {
            border: 1px solid #333;
            border-radius: 3px;
            max-height: 400px;
            overflow-y: auto;
        }
        .file-item {
            padding: 6px 8px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s;
        }
        .file-item:last-child { border-bottom: none; }
        .file-item:hover { background: #333; }
        .file-item.selected { background: #4a9eff; color: #fff; }
        .file-icon {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }
        .file-name { flex: 1; font-size: 14px; }
        .enqueue-folder-btn {
            flex: 0 0 auto;
            width: auto;
        }
        .btn-browse {
            background: #666;
            margin-top: 0;
            margin-left: 10px;
            width: auto;
            padding: 10px 15px;
        }
        .btn-browse:hover { background: #777; }
        .input-with-browse {
            display: flex;
            align-items: center;
        }
        .input-with-browse input { margin-top: 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            <div class="header-left">
                WKMP Audio Player
                <span class="connection-status" id="connection-status">Connecting...</span>
            </div>
            <div class="header-center">Developer Interface</div>
            <div class="header-right" id="build-info">Loading...</div>
        </h1>

        <div class="grid">
            <!-- Module Status (half-width) -->
            <div class="panel" style="grid-column: span 1;">
                <h2>Module Status</h2>
                <div class="status-item">
                    <span class="status-label">Playback State</span>
                    <span class="status-value" id="playback-state">Waiting for SSE...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Position</span>
                    <span class="status-value" id="position">-</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
                <div class="status-item">
                    <span class="status-label">Volume</span>
                    <span class="status-value" id="volume">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Audio Device</span>
                    <span class="status-value" id="audio-device">default</span>
                </div>
                <div class="control-group" style="margin-top: 8px;">
                    <label>Change Device</label>
                    <input type="text" id="device-input" placeholder="default">
                    <button onclick="setAudioDevice()">Set Device</button>
                    <div id="device-result"></div>
                </div>
            </div>

            <!-- Playback Controls (half-width) -->
            <div class="panel" style="grid-column: span 1;">
                <h2>Playback Controls</h2>
                <div class="button-group">
                    <button class="btn-play" onclick="controlPlayback('play')">‚ñ∂ Play</button>
                    <button class="btn-pause" onclick="controlPlayback('pause')">‚è∏ Pause</button>
                </div>
                <div class="button-group" style="margin-top: 6px;">
                    <button class="btn-skip" onclick="skipCurrentPassage()">‚è≠ Skip Current</button>
                    <button class="btn-danger" onclick="clearQueue()">üóë Clear Queue</button>
                </div>
                <div class="control-group" style="margin-top: 8px;">
                    <label>Volume (0 - 100)</label>
                    <input type="number" id="volume-input" min="0" max="100" step="5" value="75">
                    <button onclick="setVolume()">Set Volume</button>
                    <div id="volume-result"></div>
                </div>
            </div>

            <!-- Queue Contents (with Enqueue controls) -->
            <div class="panel">
                <h2>Queue Contents</h2>
                <div id="queue-display" style="margin-bottom: 8px;">Waiting for SSE...</div>
                <div class="control-group" style="border-top: 1px solid #3a3a3a; padding-top: 8px; margin-top: 8px;">
                    <label>Enqueue Passage</label>
                    <div class="input-with-browse">
                        <input type="text" id="file-path" placeholder="/path/to/audio/file.mp3">
                        <button class="btn-browse" onclick="openFileBrowser()">Browse</button>
                    </div>
                    <button onclick="enqueuePassage()">Enqueue</button>
                    <div id="enqueue-result"></div>
                </div>
            </div>

            <!-- Buffer Chain Monitor -->
            <div class="panel" style="grid-column: 1 / -1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; border-bottom: 1px solid #3a3a3a; padding-bottom: 4px;">
                    <h2 style="margin: 0;">Buffer Chain Monitor</h2>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="color: #888; font-size: 12px;">Update Rate:</label>
                        <select id="chain-update-rate" style="width: auto; padding: 4px 8px; font-size: 12px;" onchange="setChainUpdateRate()">
                            <option value="100">0.1s</option>
                            <option value="1000" selected>1.0s</option>
                            <option value="0">Manual</option>
                        </select>
                        <button style="width: auto; padding: 4px 12px; font-size: 12px; margin: 0;" onclick="forceChainUpdate()">Update</button>
                    </div>
                </div>
                <div id="buffer-chains" style="font-family: 'Courier New', monospace; font-size: 12px;">
                    <div style="color: #888;">Waiting for buffer chain data...</div>
                </div>
            </div>

            <!-- Database Settings -->
            <div class="panel" style="grid-column: 1 / -1;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; border-bottom: 1px solid #3a3a3a; padding-bottom: 4px;">
                    <h2 style="margin: 0;">Database Settings</h2>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button style="width: auto; padding: 4px 12px; font-size: 12px; margin: 0; background: #d97706; border: 1px solid #b45309;" onclick="saveAllSettings()">üíæ Save All & Restart</button>
                        <button style="width: auto; padding: 4px 12px; font-size: 12px; margin: 0;" onclick="loadSettings()">üîÑ Refresh</button>
                    </div>
                </div>
                <div id="settings-status" style="padding: 4px; margin-bottom: 6px; border-radius: 3px; display: none; font-size: 12px;"></div>
                <div style="overflow-y: auto; max-height: 400px;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <thead style="position: sticky; top: 0; background: #2a2a2a; z-index: 1;">
                            <tr style="border-bottom: 2px solid #4a9eff;">
                                <th style="padding: 6px; text-align: left; color: #4a9eff; font-weight: 600; width: 20%;">Parameter</th>
                                <th style="padding: 6px; text-align: left; color: #4a9eff; font-weight: 600; width: 8%;">Type</th>
                                <th style="padding: 6px; text-align: right; color: #4a9eff; font-weight: 600; width: 12%;">Default</th>
                                <th style="padding: 6px; text-align: left; color: #4a9eff; font-weight: 600; width: 12%;">Current Value</th>
                                <th style="padding: 6px; text-align: left; color: #4a9eff; font-weight: 600; width: 15%;">Valid Range</th>
                                <th style="padding: 6px; text-align: left; color: #4a9eff; font-weight: 600; width: 12%;">New Value</th>
                                <th style="padding: 6px; text-align: left; color: #4a9eff; font-weight: 600; width: 21%;">Description</th>
                            </tr>
                        </thead>
                        <tbody id="settings-table-body">
                            <tr>
                                <td colspan="7" style="padding: 12px; text-align: center; color: #666;">
                                    Loading settings...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Event Stream Monitor -->
            <div class="panel" style="grid-column: 1 / -1;">
                <h2>Event Stream Monitor (SSE)</h2>
                <div class="event-controls">
                    <button onclick="clearEventLog()">Clear Log</button>
                    <button onclick="exportEventLog()">Export JSON</button>
                    <button onclick="toggleEventPause()">
                        <span id="pause-text">Pause</span>
                    </button>
                </div>
                <div class="event-log" id="event-log">
                    <div class="event-item">Connecting to event stream...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- File Browser Modal -->
    <div class="modal" id="file-browser-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Browse Audio Files</h3>
                <button class="modal-close" onclick="closeFileBrowser()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="current-path" id="current-path-display">Loading...</div>
                <div class="file-list" id="file-list">
                    <div class="file-item">Loading files...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = '';
        const API_SHARED_SECRET = "{{SHARED_SECRET}}"; // Replaced by server during page render (as string to preserve precision)
        let eventSource = null;
        const maxEvents = 100;
        const eventHistory = []; // Store all events for export
        let eventsPaused = false;

        // ========================================
        // API Authentication (SPEC007 API-AUTH-025)
        // ========================================

        /**
         * Convert JSON object to canonical form (sorted keys, no whitespace)
         * Per SPEC007 API-AUTH-027
         */
        function toCanonicalJSON(obj) {
            if (obj === null) return 'null';
            if (typeof obj === 'boolean') return obj.toString();
            if (typeof obj === 'number') return obj.toString();
            if (typeof obj === 'string') {
                // Escape backslashes and quotes
                const escaped = obj.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
                return `"${escaped}"`;
            }
            if (Array.isArray(obj)) {
                const items = obj.map(toCanonicalJSON);
                return `[${items.join(',')}]`;
            }
            if (typeof obj === 'object') {
                const keys = Object.keys(obj).sort();
                const pairs = keys.map(k => `"${k}":${toCanonicalJSON(obj[k])}`);
                return `{${pairs.join(',')}}`;
            }
            return 'null';
        }

        /**
         * Calculate SHA-256 hash for API authentication
         * Per SPEC007 API-AUTH-027
         */
        async function calculateHash(jsonObj, sharedSecret) {
            // Step 1: Clone object and replace hash with dummy hash (64 zeros)
            const objWithDummyHash = { ...jsonObj };
            objWithDummyHash.hash = '0000000000000000000000000000000000000000000000000000000000000000';

            // Step 2: Convert to canonical JSON (sorted keys, no whitespace)
            const canonical = toCanonicalJSON(objWithDummyHash);

            // Step 3: Append shared secret as decimal string
            const toHash = canonical + sharedSecret.toString();

            // Step 4: Calculate SHA-256 using SubtleCrypto API
            const encoder = new TextEncoder();
            const data = encoder.encode(toHash);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);

            // Step 5: Convert to 64 hex characters
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

            return hashHex;
        }

        /**
         * Wrapper for fetch() that adds timestamp and hash authentication
         * Per SPEC007 API-AUTH-025
         */
        async function authenticatedFetch(url, options = {}) {
            // Check if authentication is disabled (shared_secret = 0)
            if (API_SHARED_SECRET === "0") {
                // Bypass mode: send dummy hash
                const timestamp = Date.now();
                const dummyHash = '0000000000000000000000000000000000000000000000000000000000000000';

                if (options.method && (options.method === 'POST' || options.method === 'PUT')) {
                    // Add to body for POST/PUT
                    if (options.body) {
                        const bodyObj = JSON.parse(options.body);
                        bodyObj.timestamp = timestamp;
                        bodyObj.hash = dummyHash;
                        options.body = JSON.stringify(bodyObj);
                    } else {
                        options.body = JSON.stringify({ timestamp, hash: dummyHash });
                    }
                } else {
                    // Add to query string for GET/DELETE
                    const separator = url.includes('?') ? '&' : '?';
                    url = `${url}${separator}timestamp=${timestamp}&hash=${dummyHash}`;
                }

                return fetch(url, options);
            }

            // Normal authenticated mode
            const timestamp = Date.now();

            if (options.method && (options.method === 'POST' || options.method === 'PUT')) {
                // POST/PUT: Add timestamp and hash to body
                let bodyObj = {};
                if (options.body) {
                    bodyObj = JSON.parse(options.body);
                }
                bodyObj.timestamp = timestamp;

                // Calculate hash
                const hash = await calculateHash(bodyObj, API_SHARED_SECRET);
                bodyObj.hash = hash;

                options.body = JSON.stringify(bodyObj);
                options.headers = options.headers || {};
                options.headers['Content-Type'] = 'application/json';

                return fetch(url, options);
            } else {
                // GET/DELETE: Add timestamp and hash to query string
                const queryObj = { timestamp, hash: 'dummy' };
                const hash = await calculateHash(queryObj, API_SHARED_SECRET);

                const separator = url.includes('?') ? '&' : '?';
                url = `${url}${separator}timestamp=${timestamp}&hash=${hash}`;

                return fetch(url, options);
            }
        }

        // Fetch initial state from API
        async function fetchInitialState() {
            try {
                // Fetch build info
                const buildResponse = await authenticatedFetch(`${API_BASE}/build_info`);
                if (buildResponse.ok) {
                    const buildData = await buildResponse.json();
                    const buildInfo = `v${buildData.version} [${buildData.git_hash}] ${buildData.build_timestamp} (${buildData.build_profile})`;
                    document.getElementById('build-info').textContent = buildInfo;
                }

                // Fetch playback state
                const stateResponse = await authenticatedFetch(`${API_BASE}/playback/state`);
                if (stateResponse.ok) {
                    const stateData = await stateResponse.json();
                    updatePlaybackState(stateData.state);
                }

                // Fetch queue
                const queueResponse = await authenticatedFetch(`${API_BASE}/playback/queue`);
                if (queueResponse.ok) {
                    const queueData = await queueResponse.json();
                    updateQueueDisplay(queueData.queue);
                }

                // Fetch position
                const positionResponse = await authenticatedFetch(`${API_BASE}/playback/position`);
                if (positionResponse.ok) {
                    const positionData = await positionResponse.json();
                    updatePosition(positionData);
                }

                // Fetch volume
                const volumeResponse = await authenticatedFetch(`${API_BASE}/audio/volume`);
                if (volumeResponse.ok) {
                    const volumeData = await volumeResponse.json();
                    updateVolumeDisplay(volumeData.volume);
                }

                // Fetch buffer chains
                const bufferResponse = await authenticatedFetch(`${API_BASE}/playback/buffer_chains`);
                if (bufferResponse.ok) {
                    const bufferData = await bufferResponse.json();
                    updateBufferChainDisplay(bufferData.chains);
                }

                // Load settings
                await loadSettings();
            } catch (err) {
                console.error('Failed to fetch initial state:', err);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            fetchInitialState();
            connectEventStream();
        });

        // Connect to SSE event stream with auto-reconnect
        function connectEventStream() {
            const logEl = document.getElementById('event-log');
            const statusEl = document.getElementById('connection-status');

            if (eventSource) {
                eventSource.close();
            }

            updateConnectionStatus('connecting');
            eventSource = new EventSource(`${API_BASE}/events`);

            eventSource.onopen = () => {
                updateConnectionStatus('connected');
                addEvent('system', 'Connected to SSE event stream');
            };

            eventSource.onerror = (err) => {
                updateConnectionStatus('disconnected');
                addEvent('system', 'SSE connection error, auto-reconnecting...');
                // EventSource automatically reconnects
            };

            // Handle all event types
            eventSource.addEventListener('InitialState', (e) => {
                handleInitialState(JSON.parse(e.data));
            });

            eventSource.addEventListener('QueueStateUpdate', (e) => {
                console.log('QueueStateUpdate SSE event received, raw data:', e.data);
                const parsedData = JSON.parse(e.data);
                console.log('Parsed QueueStateUpdate data:', parsedData);
                handleQueueStateUpdate(parsedData);
            });

            eventSource.addEventListener('PlaybackPosition', (e) => {
                handlePlaybackPosition(JSON.parse(e.data));
            });

            eventSource.addEventListener('VolumeChanged', (e) => {
                handleVolumeChanged(JSON.parse(e.data));
            });

            eventSource.addEventListener('PlaybackStateChanged', (e) => {
                handlePlaybackStateChanged(JSON.parse(e.data));
            });

            eventSource.addEventListener('CrossfadeStarted', (e) => {
                handleCrossfadeStarted(JSON.parse(e.data));
            });

            eventSource.addEventListener('PassageStarted', (e) => {
                handlePassageStarted(JSON.parse(e.data));
            });

            eventSource.addEventListener('PassageCompleted', (e) => {
                handlePassageCompleted(JSON.parse(e.data));
            });

            eventSource.addEventListener('BufferChainStatus', (e) => {
                handleBufferChainStatus(JSON.parse(e.data));
            });

            // Fallback for unknown events
            eventSource.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    addEvent(data.type || 'unknown', JSON.stringify(data, null, 2));
                } catch (err) {
                    addEvent('raw', e.data);
                }
            };
        }

        // SSE Event Handlers
        function handleInitialState(data) {
            addEvent('InitialState', JSON.stringify(data, null, 2));

            // Update queue
            if (data.queue) {
                updateQueueDisplay(data.queue);
            }

            // Update position
            if (data.position) {
                updatePosition(data.position);
            }

            // Update volume
            if (typeof data.volume === 'number') {
                updateVolumeDisplay(data.volume);
            }
        }

        function handleQueueStateUpdate(data) {
            console.log('handleQueueStateUpdate called with data:', data);
            addEvent('QueueStateUpdate', `Queue updated: ${data.queue.length} entries`);
            console.log('About to call updateQueueDisplay with queue:', data.queue);
            updateQueueDisplay(data.queue);
            console.log('updateQueueDisplay completed');
        }

        function handlePlaybackPosition(data) {
            // Don't log every position update (too spammy), just update UI
            updatePosition({
                passage_id: data.passage_id,
                position_ms: data.position_ms,
                duration_ms: data.duration_ms,
                playing: data.playing
            });
        }

        function handleVolumeChanged(data) {
            addEvent('VolumeChanged', `Volume: ${Math.round(data.new_volume * 100)}%`);
            updateVolumeDisplay(data.new_volume);
        }

        function handlePlaybackStateChanged(data) {
            addEvent('PlaybackStateChanged', `State: ${data.state}`);
            updatePlaybackState(data.state);
        }

        function handleCrossfadeStarted(data) {
            addEvent('CrossfadeStarted', `From: ${data.from_passage_id.substring(0, 8)}... To: ${data.to_passage_id.substring(0, 8)}...`);
        }

        function handlePassageStarted(data) {
            addEvent('PassageStarted', `Passage: ${data.passage_id.substring(0, 8)}...`);
        }

        function handlePassageCompleted(data) {
            const status = data.completed ? 'completed' : 'skipped';
            addEvent('PassageCompleted', `Passage: ${data.passage_id.substring(0, 8)}... (${status})`);
        }

        function handleBufferChainStatus(data) {
            // Don't add to event log (too noisy)
            // **[SPEC020-MONITOR-120]** Directly update display from SSE events
            updateBufferChainDisplay(data.chains);
        }

        // UI Update Functions
        function updateQueueDisplay(queue) {
            const queueEl = document.getElementById('queue-display');

            if (!queue || queue.length === 0) {
                queueEl.innerHTML = '<div class="queue-empty">Queue is empty</div>';
                return;
            }

            console.log('Updating queue display with entries:', queue);

            queueEl.innerHTML = queue.map(item => {
                console.log('Queue item:', item);
                return `
                <div class="queue-item">
                    <div class="queue-item-content">
                        <div>${item.file_path || 'Unknown'}</div>
                        <div class="queue-item-id">ID: ${item.queue_entry_id || 'N/A'}</div>
                    </div>
                    <button class="queue-item-remove" onclick="removeQueueEntry('${item.queue_entry_id}')" title="Remove from queue">‚úï</button>
                </div>
            `;
            }).join('');
        }

        function updatePosition(position) {
            if (!position) {
                document.getElementById('position').textContent = '-';
                document.getElementById('progress-fill').style.width = '0%';
                return;
            }

            const posMs = position.position_ms || 0;
            const durMs = position.duration_ms || 0;
            const posSec = Math.floor(posMs / 1000);
            const durSec = Math.floor(durMs / 1000);

            // Show "?" for unknown duration (ephemeral passages before decode completes)
            const durationText = (durMs < 1000) ? '?' : formatTime(durSec);
            document.getElementById('position').textContent = `${formatTime(posSec)} / ${durationText}`;

            const progress = durMs > 0 ? (posMs / durMs * 100) : 0;
            document.getElementById('progress-fill').style.width = progress + '%';
        }

        function updateBufferChainDisplay(chains) {
            const el = document.getElementById('buffer-chains');
            if (!chains || chains.length === 0) {
                el.innerHTML = '<div style="color: #888;">No buffer chains</div>';
                return;
            }

            // Ensure we display all 12 chains, filling in missing ones as idle
            const allChains = [];
            for (let i = 0; i < 12; i++) {
                const existingChain = chains.find(c => c.slot_index === i);
                if (existingChain) {
                    allChains.push(existingChain);
                } else {
                    // Create idle placeholder
                    allChains.push({
                        slot_index: i,
                        queue_position: null,
                        buffer_state: 'Empty',
                        buffer_fill_percent: 0,
                        buffer_fill_samples: 0,
                        buffer_capacity_samples: 0,
                        mixer_role: 'Idle',
                        is_active_in_mixer: false,
                        file_name: null,
                        passage_id: null,
                        playback_position_ms: 0,
                        duration_ms: 0
                    });
                }
            }

            // **[SPEC020-MONITOR-020]** Sort by slot_index for uniform table display
            allChains.sort((a, b) => a.slot_index - b.slot_index);

            // **[SPEC020-MONITOR-030]** Build table with 8 columns
            let html = `
                <table class="buffer-chain-table">
                    <thead>
                        <tr>
                            <th>Chain #</th>
                            <th>Queue Pos</th>
                            <th>Decoder</th>
                            <th>Resample</th>
                            <th>Fade</th>
                            <th>Buffer</th>
                            <th>Mixer</th>
                            <th>File Name</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            // Render all chains in order (0-11)
            allChains.forEach(chain => {
                html += renderChainRow(chain);
            });

            html += `
                    </tbody>
                </table>
            `;
            el.innerHTML = html;
        }

        // **[SPEC020-MONITOR-030]** Render single table row for a chain
        function renderChainRow(chain) {
            const slotIndex = chain.slot_index;
            const queuePos = chain.queue_position;
            const isIdle = queuePos === null || queuePos === undefined;

            // **[SPEC020-MONITOR-050]** Queue position: 0=now playing, 1=up next, 2+=queued, N/A=idle
            let queuePosDisplay = 'N/A';
            let rowClass = 'idle';
            if (queuePos === 0) {
                queuePosDisplay = '0';
                rowClass = 'pos-0';
            } else if (queuePos === 1) {
                queuePosDisplay = '1';
                rowClass = 'pos-1';
            } else if (queuePos !== null && queuePos !== undefined) {
                queuePosDisplay = queuePos.toString();
                rowClass = 'pos-queued';
            }

            // **[SPEC020-MONITOR-060]** Decoder status - show decoded audio duration (MM:SS)
            const totalDecodedFrames = chain.total_decoded_frames || 0;
            const decodedSeconds = Math.floor(totalDecodedFrames / 44100); // 44.1kHz sample rate
            const decodedMinutes = Math.floor(decodedSeconds / 60);
            const decodedSecsRemainder = decodedSeconds % 60;
            const decoderDisplay = isIdle ? '-' :
                `${decodedMinutes}:${decodedSecsRemainder.toString().padStart(2, '0')}`;

            // **[SPEC020-MONITOR-070]** Resample status
            const sampleRate = chain.source_sample_rate || 0;
            const targetSampleRate = chain.target_sample_rate || 44100; // **[DBD-PARAM-020]** Device native rate
            const algorithm = chain.resampler_algorithm || '';
            let resampleDisplay;
            if (isIdle) {
                resampleDisplay = 'N/A';
            } else if (sampleRate === targetSampleRate || sampleRate === 0) {
                // No resampling needed
                resampleDisplay = algorithm ? `N/A ${targetSampleRate} Hz [${algorithm}]` : `N/A ${targetSampleRate} Hz`;
            } else {
                // Active resampling
                resampleDisplay = algorithm
                    ? `${sampleRate} Hz ‚Üí ${targetSampleRate} Hz [${algorithm}]`
                    : `${sampleRate} Hz ‚Üí ${targetSampleRate} Hz`;
            }

            // **[SPEC020-MONITOR-080]** Fade status
            const fadeStage = chain.fade_stage || 'N/A';
            const fadeCurve = chain.fade_in_curve || chain.fade_out_curve || '';
            const fadeDisplay = isIdle ? '-' :
                (fadeCurve ? `${fadeStage} (${fadeCurve})` : fadeStage);

            // **[SPEC020-MONITOR-090]** Buffer fill
            const bufferPct = chain.buffer_fill_percent?.toFixed(1) || '0.0';
            const bufferDisplay = `${bufferPct}%`;

            // **[SPEC020-MONITOR-100]** Mixer status
            const mixerRole = chain.mixer_role || 'Idle';
            const isActive = chain.is_active_in_mixer;
            const mixerDisplay = isActive ? `${mixerRole} ‚úì` : mixerRole;

            // File name display
            const fileName = chain.file_name || '-';

            return `
                <tr class="chain-row ${rowClass}">
                    <td class="chain-num">${slotIndex}</td>
                    <td class="queue-pos">${queuePosDisplay}</td>
                    <td class="decoder">${decoderDisplay}</td>
                    <td class="resample">${resampleDisplay}</td>
                    <td class="fade">${fadeDisplay}</td>
                    <td class="buffer">
                        <div class="buffer-bar-container">
                            <div class="buffer-bar-fill" style="width: ${bufferPct}%;"></div>
                            <span class="buffer-text">${bufferDisplay}</span>
                        </div>
                    </td>
                    <td class="mixer">${mixerDisplay}</td>
                    <td class="file-name-cell">${fileName}</td>
                </tr>
            `;
        }

        function formatNumber(num) {
            return num.toLocaleString();
        }

        function updateVolumeDisplay(volume) {
            // Validate that volume is a valid number
            if (typeof volume !== 'number' || isNaN(volume)) {
                console.warn('Invalid volume value received:', volume);
                return; // Keep existing display values
            }

            const volumePercent = Math.round(volume * 100);
            document.getElementById('volume').textContent = volumePercent + '%';
            document.getElementById('volume-input').value = volumePercent;
        }

        function updatePlaybackState(state) {
            const stateEl = document.getElementById('playback-state');
            stateEl.textContent = state;
            stateEl.className = 'status-value ' + (state === 'playing' ? 'state-playing' : 'state-paused');
        }

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connection-status');
            statusEl.className = 'connection-status status-' + status;
            statusEl.textContent = status === 'connected' ? 'Connected' :
                                  status === 'connecting' ? 'Connecting...' : 'Disconnected';
        }

        // Event Log Functions
        function addEvent(type, data) {
            if (eventsPaused) return;

            const logEl = document.getElementById('event-log');
            const time = new Date().toLocaleTimeString();
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event-item';
            eventDiv.innerHTML = `
                <span class="event-time">[${time}]</span>
                <span class="event-type event-type-${escapeHtml(type)}">${escapeHtml(type)}</span>:
                <span class="event-data">${escapeHtml(data)}</span>
            `;
            logEl.insertBefore(eventDiv, logEl.firstChild);

            // Store in history
            eventHistory.unshift({ time, type, data });

            // Keep only last N events in DOM
            while (logEl.children.length > maxEvents) {
                logEl.removeChild(logEl.lastChild);
            }

            // Keep only last N*2 events in history
            if (eventHistory.length > maxEvents * 2) {
                eventHistory.length = maxEvents * 2;
            }
        }

        function clearEventLog() {
            document.getElementById('event-log').innerHTML = '';
            eventHistory.length = 0;
            addEvent('system', 'Event log cleared');
        }

        function exportEventLog() {
            const dataStr = JSON.stringify(eventHistory, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `wkmp-events-${new Date().toISOString()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            addEvent('system', 'Event log exported');
        }

        function toggleEventPause() {
            eventsPaused = !eventsPaused;
            document.getElementById('pause-text').textContent = eventsPaused ? 'Resume' : 'Pause';
            addEvent('system', eventsPaused ? 'Event logging paused' : 'Event logging resumed');
        }

        // Playback control
        async function controlPlayback(action) {
            try {
                const response = await authenticatedFetch(`${API_BASE}/playback/${action}`, { method: 'POST' });
                if (!response.ok) {
                    console.error(`Failed to ${action}`);
                }
            } catch (err) {
                console.error(`Failed to ${action}:`, err);
            }
        }

        // Skip current passage
        async function skipCurrentPassage() {
            try {
                const response = await authenticatedFetch(`${API_BASE}/playback/next`, { method: 'POST' });
                if (!response.ok) {
                    console.error('Failed to skip passage');
                }
            } catch (err) {
                console.error('Failed to skip passage:', err);
            }
        }

        // Clear entire queue
        async function clearQueue() {
            if (!confirm('Clear entire queue? This will remove all passages.')) {
                return;
            }
            try {
                const response = await authenticatedFetch(`${API_BASE}/playback/queue/clear`, { method: 'POST' });
                if (!response.ok) {
                    console.error('Failed to clear queue');
                }
            } catch (err) {
                console.error('Failed to clear queue:', err);
            }
        }

        // Remove single queue entry
        async function removeQueueEntry(queueEntryId) {
            if (!queueEntryId) {
                console.error('No queue entry ID provided');
                return;
            }
            console.log('Attempting to remove queue entry:', queueEntryId);
            try {
                const response = await authenticatedFetch(`${API_BASE}/playback/queue/${queueEntryId}`, { method: 'DELETE' });
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Failed to remove queue entry:', queueEntryId, 'Error:', errorText);
                    addEvent('system', `Failed to remove queue entry: ${errorText}`);
                } else {
                    console.log('Successfully removed queue entry:', queueEntryId);
                }
            } catch (err) {
                console.error('Failed to remove queue entry:', queueEntryId, 'Exception:', err);
                addEvent('system', `Error removing queue entry: ${err.message}`);
            }
        }

        // Set volume
        async function setVolume() {
            const resultEl = document.getElementById('volume-result');
            try {
                const userVolume = parseInt(document.getElementById('volume-input').value);
                const apiVolume = userVolume / 100.0;
                const response = await authenticatedFetch(`${API_BASE}/audio/volume`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ volume: apiVolume })
                });
                if (response.ok) {
                    resultEl.innerHTML = '<div class="success">‚úì Volume set</div>';
                } else {
                    resultEl.innerHTML = '<div class="error">‚úó Failed</div>';
                }
            } catch (err) {
                resultEl.innerHTML = '<div class="error">‚úó Error: ' + err.message + '</div>';
            }
            setTimeout(() => resultEl.innerHTML = '', 3000);
        }

        // Set audio device
        async function setAudioDevice() {
            const resultEl = document.getElementById('device-result');
            try {
                const device = document.getElementById('device-input').value;
                const response = await authenticatedFetch(`${API_BASE}/audio/device`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device })
                });
                if (response.ok) {
                    resultEl.innerHTML = '<div class="success">‚úì Device set</div>';
                } else {
                    resultEl.innerHTML = '<div class="error">‚úó Failed</div>';
                }
            } catch (err) {
                resultEl.innerHTML = '<div class="error">‚úó Error: ' + err.message + '</div>';
            }
            setTimeout(() => resultEl.innerHTML = '', 3000);
        }

        // Enqueue passage
        async function enqueuePassage() {
            const resultEl = document.getElementById('enqueue-result');
            try {
                const filePath = document.getElementById('file-path').value;
                if (!filePath) {
                    resultEl.innerHTML = '<div class="error">‚úó Enter a file path</div>';
                    return;
                }
                const response = await authenticatedFetch(`${API_BASE}/playback/enqueue`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ file_path: filePath })
                });
                if (response.ok) {
                    resultEl.innerHTML = '<div class="success">‚úì Enqueued</div>';
                } else {
                    const error = await response.text();
                    resultEl.innerHTML = '<div class="error">‚úó ' + error + '</div>';
                }
            } catch (err) {
                resultEl.innerHTML = '<div class="error">‚úó Error: ' + err.message + '</div>';
            }
            setTimeout(() => resultEl.innerHTML = '', 3000);
        }

        async function enqueueFolderRecursive(folderPath) {
            try {
                addEvent('FolderEnqueue', `Enqueueing folder: ${folderPath}`);
                const response = await authenticatedFetch(`${API_BASE}/playback/enqueue-folder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder_path: folderPath })
                });
                if (response.ok) {
                    const data = await response.json();
                    addEvent('FolderEnqueue', `‚úì Enqueued ${data.files_enqueued} files (${data.files_skipped} skipped)`);
                } else {
                    const error = await response.text();
                    addEvent('FolderEnqueue', `‚úó Error: ${error}`);
                }
            } catch (err) {
                addEvent('FolderEnqueue', `‚úó Error: ${err.message}`);
            }
        }

        // ============================================================================
        // Settings Management Functions
        // ============================================================================

        // Load all settings from the API
        async function loadSettings() {
            const tableBody = document.getElementById('settings-table-body');
            const statusEl = document.getElementById('settings-status');

            try {
                statusEl.style.display = 'block';
                statusEl.style.background = '#3b82f6';
                statusEl.textContent = 'Loading settings...';

                const response = await authenticatedFetch(`${API_BASE}/settings/all`);
                if (!response.ok) {
                    throw new Error('Failed to fetch settings');
                }

                const data = await response.json();

                // Clear table
                tableBody.innerHTML = '';

                // Populate table with settings
                data.settings.forEach(setting => {
                    const row = document.createElement('tr');
                    row.style.borderBottom = '1px solid #333';

                    // 1. Parameter name
                    const nameCell = document.createElement('td');
                    nameCell.style.padding = '8px 6px';
                    nameCell.style.fontFamily = "'Courier New', monospace";
                    nameCell.style.fontSize = '11px';
                    nameCell.style.color = '#a5f3fc';
                    nameCell.textContent = setting.key;
                    row.appendChild(nameCell);

                    // 2. Type
                    const typeCell = document.createElement('td');
                    typeCell.style.padding = '8px 6px';
                    typeCell.style.color = '#fbbf24';
                    typeCell.style.fontSize = '11px';
                    typeCell.textContent = setting.data_type;
                    row.appendChild(typeCell);

                    // 3. Default value
                    const defaultCell = document.createElement('td');
                    defaultCell.style.padding = '8px 6px';
                    defaultCell.style.fontFamily = "'Courier New', monospace";
                    defaultCell.style.color = '#888';
                    defaultCell.style.fontSize = '13px';
                    defaultCell.style.textAlign = 'right';
                    defaultCell.textContent = setting.default_value;
                    row.appendChild(defaultCell);

                    // 4. Current value (highlight if different from default)
                    const currentCell = document.createElement('td');
                    currentCell.style.padding = '8px 6px';
                    currentCell.style.fontFamily = "'Courier New', monospace";
                    currentCell.style.fontSize = '13px';

                    // Check if current value differs from default
                    const isDifferent = setting.value !== '(not set)' && setting.value !== setting.default_value;
                    if (isDifferent) {
                        // Highlighted: orange background with yellow text
                        currentCell.style.background = '#854d0e';
                        currentCell.style.color = '#fef08a';
                        currentCell.style.fontWeight = '600';
                    } else {
                        // Normal: green text
                        currentCell.style.color = '#4ade80';
                    }
                    currentCell.textContent = setting.value;
                    row.appendChild(currentCell);

                    // 5. Valid range
                    const rangeCell = document.createElement('td');
                    rangeCell.style.padding = '8px 6px';
                    rangeCell.style.fontFamily = "'Courier New', monospace";
                    rangeCell.style.color = '#60a5fa';
                    rangeCell.style.fontSize = '13px';
                    rangeCell.textContent = setting.validation || '-';
                    row.appendChild(rangeCell);

                    // 6. New value input
                    const inputCell = document.createElement('td');
                    inputCell.style.padding = '4px 6px';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `setting-${setting.key}`;
                    input.placeholder = setting.value;
                    input.style.width = '100%';
                    input.style.padding = '4px 6px';
                    input.style.background = '#1a1a1a';
                    input.style.border = '1px solid #3a3a3a';
                    input.style.borderRadius = '3px';
                    input.style.color = '#e0e0e0';
                    input.style.fontSize = '11px';
                    input.style.fontFamily = "'Courier New', monospace";
                    inputCell.appendChild(input);
                    row.appendChild(inputCell);

                    // 7. Description only (validation moved to separate column)
                    const descCell = document.createElement('td');
                    descCell.style.padding = '8px 6px';
                    descCell.style.fontSize = '11px';
                    descCell.style.color = '#999';
                    descCell.textContent = setting.description;
                    row.appendChild(descCell);

                    tableBody.appendChild(row);
                });

                statusEl.style.background = '#10b981';
                statusEl.textContent = `‚úì Loaded ${data.settings.length} settings`;
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);

            } catch (err) {
                console.error('Failed to load settings:', err);
                statusEl.style.background = '#ef4444';
                statusEl.textContent = '‚úó Error loading settings: ' + err.message;
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="7" style="padding: 12px; text-align: center; color: #f87171;">
                            Error loading settings: ${err.message}
                        </td>
                    </tr>
                `;
            }
        }

        // Save all modified settings
        async function saveAllSettings() {
            const statusEl = document.getElementById('settings-status');

            try {
                // Collect all modified settings
                const modifiedSettings = {};
                const inputs = document.querySelectorAll('[id^="setting-"]');

                inputs.forEach(input => {
                    const value = input.value.trim();
                    if (value !== '') {
                        const key = input.id.replace('setting-', '');
                        modifiedSettings[key] = value;
                    }
                });

                // Check if any settings were modified
                if (Object.keys(modifiedSettings).length === 0) {
                    statusEl.style.display = 'block';
                    statusEl.style.background = '#f59e0b';
                    statusEl.textContent = '‚ö† No settings modified. Enter new values in the "New Value" column.';
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 4000);
                    return;
                }

                // Confirm before saving and restarting
                const confirmMsg = `You are about to update ${Object.keys(modifiedSettings).length} setting(s).\n\nThe application will shut down in 2 seconds after saving.\n\nYou will need to manually restart it.\n\nContinue?`;
                if (!confirm(confirmMsg)) {
                    return;
                }

                statusEl.style.display = 'block';
                statusEl.style.background = '#3b82f6';
                statusEl.textContent = `Saving ${Object.keys(modifiedSettings).length} settings...`;

                const response = await authenticatedFetch(`${API_BASE}/settings/bulk_update`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ settings: modifiedSettings })
                });

                if (!response.ok) {
                    throw new Error('Failed to save settings');
                }

                const data = await response.json();

                statusEl.style.background = '#10b981';
                statusEl.textContent = `‚úì ${data.message}`;

                // Disable all inputs and buttons
                document.querySelectorAll('input, button').forEach(el => {
                    el.disabled = true;
                });

            } catch (err) {
                console.error('Failed to save settings:', err);
                statusEl.style.display = 'block';
                statusEl.style.background = '#ef4444';
                statusEl.textContent = '‚úó Error saving settings: ' + err.message;
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // File Browser Functions
        let currentBrowserPath = null;
        let selectedFilePath = null;

        async function openFileBrowser() {
            const modal = document.getElementById('file-browser-modal');
            modal.classList.add('open');
            await loadDirectory();
        }

        function closeFileBrowser() {
            const modal = document.getElementById('file-browser-modal');
            modal.classList.remove('open');
            selectedFilePath = null;
        }

        async function loadDirectory(path = null) {
            const pathDisplay = document.getElementById('current-path-display');
            const fileList = document.getElementById('file-list');

            try {
                const url = path
                    ? `${API_BASE}/files/browse?path=${encodeURIComponent(path)}`
                    : `${API_BASE}/files/browse`;

                const response = await authenticatedFetch(url);
                if (!response.ok) {
                    const error = await response.json();
                    fileList.innerHTML = `<div class="file-item" style="color: #f87171;">Error: ${error.status || 'Failed to load directory'}</div>`;
                    return;
                }

                const data = await response.json();
                currentBrowserPath = data.current_path;
                pathDisplay.textContent = data.current_path;

                if (data.entries.length === 0) {
                    fileList.innerHTML = '<div class="file-item" style="color: #888;">No files or directories found</div>';
                    return;
                }

                let html = '';

                if (data.parent_path) {
                    html += `
                        <div class="file-item" data-path="${escapeHtml(data.parent_path)}" data-action="directory">
                            <span class="file-icon">üìÅ</span>
                            <span class="file-name">..</span>
                        </div>
                    `;
                }

                data.entries.forEach(entry => {
                    const icon = entry.is_directory ? 'üìÅ' : 'üéµ';
                    const action = entry.is_directory ? 'directory' : 'file';
                    const color = entry.is_audio_file ? '#4ade80' : '#e0e0e0';

                    if (entry.is_directory) {
                        html += `
                            <div class="file-item" data-path="${escapeHtml(entry.path)}" data-action="${action}">
                                <span class="file-icon">${icon}</span>
                                <span class="file-name" style="color: ${color};">${escapeHtml(entry.name)}</span>
                                <button class="enqueue-folder-btn" onclick="event.stopPropagation(); enqueueFolderRecursive('${escapeJs(entry.path)}');" style="padding: 2px 8px; font-size: 11px; background: #10b981; color: white; border: none; border-radius: 3px; cursor: pointer;">Enqueue</button>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="file-item" data-path="${escapeHtml(entry.path)}" data-action="${action}">
                                <span class="file-icon">${icon}</span>
                                <span class="file-name" style="color: ${color};">${escapeHtml(entry.name)}</span>
                            </div>
                        `;
                    }
                });

                fileList.innerHTML = html;

                fileList.querySelectorAll('.file-item[data-path]').forEach(item => {
                    item.addEventListener('click', () => {
                        const path = item.getAttribute('data-path');
                        const action = item.getAttribute('data-action');
                        if (action === 'directory') {
                            loadDirectory(path);
                        } else {
                            selectFile(path);
                        }
                    });
                });
            } catch (err) {
                fileList.innerHTML = `<div class="file-item" style="color: #f87171;">Error: ${err.message}</div>`;
            }
        }

        function selectFile(path) {
            document.getElementById('file-path').value = path;
            selectedFilePath = path;
            closeFileBrowser();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Escape string for use in JavaScript string literals (e.g., onclick attributes)
        // Handles backslashes in Windows paths
        function escapeJs(text) {
            return text.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
        }

        // **[SPEC020-MONITOR-120]** Buffer Chain Update Rate Control Functions

        /**
         * Set the buffer chain update rate on the server via API
         * **[SPEC020-MONITOR-120]** Calls POST /playback/buffer_monitor/rate
         */
        async function setChainUpdateRate() {
            const select = document.getElementById('chain-update-rate');
            const rate_ms = parseInt(select.value);

            try {
                const response = await authenticatedFetch(`${API_BASE}/playback/buffer_monitor/rate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rate_ms })
                });

                if (response.ok) {
                    const modeStr = rate_ms === 0 ? 'Manual' : rate_ms === 100 ? '0.1s' : '1.0s';
                    console.log(`Buffer monitor rate set to: ${modeStr}`);
                } else {
                    console.error('Failed to set buffer monitor rate');
                }
            } catch (err) {
                console.error('Failed to set buffer monitor rate:', err);
            }
        }

        /**
         * Force an immediate update of buffer chain display via API
         * **[SPEC020-MONITOR-130]** Calls POST /playback/buffer_monitor/update
         */
        async function forceChainUpdate() {
            try {
                const response = await authenticatedFetch(`${API_BASE}/playback/buffer_monitor/update`, {
                    method: 'POST'
                });

                if (response.ok) {
                    console.log('Buffer monitor update triggered');
                } else {
                    console.error('Failed to trigger buffer monitor update');
                }
            } catch (err) {
                console.error('Failed to trigger buffer monitor update:', err);
            }
        }

    </script>
</body>
</html>
