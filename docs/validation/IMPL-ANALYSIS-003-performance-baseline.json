{
  "analysis_date": "2025-10-19",
  "analysis_type": "code_based_estimation",
  "server_status": "not_running",
  "note": "Baseline established from static code analysis. Live measurements will follow when server is started.",

  "startup_path_analysis": {
    "description": "Critical path from API enqueue request to first audio sample",
    "steps": [
      {
        "step": "API request parsing",
        "estimated_time_ms": 1,
        "location": "wkmp-ap/src/api/handlers.rs:294-327",
        "is_async": true,
        "notes": "Axum handler extracts JSON, validates file path"
      },
      {
        "step": "File existence validation",
        "estimated_time_ms": 5,
        "location": "wkmp-ap/src/playback/engine.rs:979-991",
        "is_synchronous": true,
        "notes": "File system check (fast on local SSD)"
      },
      {
        "step": "Create ephemeral passage + timing validation",
        "estimated_time_ms": 2,
        "location": "wkmp-ap/src/playback/engine.rs:993-1006",
        "is_synchronous": true,
        "notes": "In-memory passage object creation and validation"
      },
      {
        "step": "Database INSERT (queue entry)",
        "estimated_time_ms": 50,
        "location": "wkmp-ap/src/playback/engine.rs:1009-1023",
        "is_synchronous": true,
        "is_database": true,
        "notes": "SQLite INSERT with timing parameters. Async but sequential."
      },
      {
        "step": "In-memory queue update",
        "estimated_time_ms": 1,
        "location": "wkmp-ap/src/playback/engine.rs:1041",
        "is_synchronous": false,
        "notes": "QueueManager.enqueue() - fast in-memory operation"
      },
      {
        "step": "Wait for playback loop polling tick",
        "estimated_time_ms": 50,
        "location": "wkmp-ap/src/playback/engine.rs:1066-1100",
        "is_synchronous": false,
        "notes": "100ms polling interval - average wait is 50ms. OPTIMIZATION: Event-driven notification implemented but polling still exists."
      },
      {
        "step": "Submit decode request to pool",
        "estimated_time_ms": 2,
        "location": "wkmp-ap/src/playback/engine.rs:1217-1218",
        "is_synchronous": false,
        "notes": "Priority queue insertion + condvar notify"
      },
      {
        "step": "Worker wakes from condvar",
        "estimated_time_ms": 1,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:195-196",
        "is_synchronous": false,
        "notes": "Condvar notification - sub-millisecond wake time"
      },
      {
        "step": "Open audio file + symphonia probe",
        "estimated_time_ms": 100,
        "location": "wkmp-ap/src/audio/decoder.rs (via SimpleDecoder::decode_passage)",
        "is_synchronous": true,
        "is_io": true,
        "notes": "File open + codec detection (MP3/FLAC). Varies by file size and codec."
      },
      {
        "step": "Seek to passage start_time_ms",
        "estimated_time_ms": 30,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:274",
        "is_synchronous": true,
        "notes": "Linear decode-and-skip implementation. Time varies with start_time offset."
      },
      {
        "step": "Decode audio (until min_buffer_threshold)",
        "estimated_time_ms": 800,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:295-296",
        "is_synchronous": true,
        "cpu_bound": true,
        "notes": "CPU-bound decode. Estimate for 500-3000ms of MP3 audio. FLAC is faster, AAC may be slower. Depends on codec, bitrate, and CPU speed."
      },
      {
        "step": "Resample to 44.1kHz (if needed)",
        "estimated_time_ms": 200,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:306-317",
        "is_synchronous": true,
        "cpu_bound": true,
        "notes": "Rubato resampling (only if source != 44100 Hz). Estimate assumes 48kHz source."
      },
      {
        "step": "Convert to stereo (if mono)",
        "estimated_time_ms": 50,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:320-328",
        "is_synchronous": true,
        "notes": "Sample duplication for mono sources. Fast memory operation."
      },
      {
        "step": "Append samples to buffer (incremental)",
        "estimated_time_ms": 10,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:364-380",
        "is_synchronous": false,
        "notes": "RwLock write + Vec append. Happens multiple times during decode (chunked appends)."
      },
      {
        "step": "Wait for minimum buffer threshold",
        "estimated_time_ms": 0,
        "location": "wkmp-ap/src/playback/buffer_manager.rs:90-136",
        "is_synchronous": false,
        "notes": "OPTIMIZATION APPLIED: Event-driven notification when buffer >= threshold. First passage uses 500ms threshold, subsequent use configured threshold (default 3000ms)."
      },
      {
        "step": "Buffer ready event notification",
        "estimated_time_ms": 1,
        "location": "wkmp-ap/src/playback/buffer_manager.rs:131-135",
        "is_synchronous": false,
        "notes": "mpsc::UnboundedSender send - sub-millisecond"
      },
      {
        "step": "Load passage timing from DB",
        "estimated_time_ms": 20,
        "location": "wkmp-ap/src/playback/engine.rs:1249",
        "is_database": true,
        "notes": "Database query for passage timing. Could be cached to eliminate."
      },
      {
        "step": "Load song timeline from DB",
        "estimated_time_ms": 30,
        "location": "wkmp-ap/src/playback/engine.rs:1253",
        "is_database": true,
        "notes": "Optional query for passage->song mapping. Skipped for ephemeral passages."
      },
      {
        "step": "Initialize CrossfadeMixer",
        "estimated_time_ms": 10,
        "location": "wkmp-ap/src/playback/engine.rs:1283-1336",
        "is_synchronous": false,
        "notes": "Mixer state update + fade curve setup"
      },
      {
        "step": "Audio output begins (cpal callback)",
        "estimated_time_ms": 20,
        "location": "wkmp-ap/src/audio/output.rs:255-283",
        "is_synchronous": false,
        "notes": "First audio callback receives frames from mixer. Latency depends on audio buffer size."
      }
    ],
    "estimated_total_startup_ms_best_case": 1383,
    "estimated_total_startup_ms_typical": 1500,
    "estimated_total_startup_ms_worst_case": 3200,
    "notes": "Best case: MP3 @ 44.1kHz stereo, no resampling, 500ms first-passage buffer. Worst case: 48kHz source requiring resample, 3000ms buffer threshold, high CPU load.",
    "critical_bottlenecks": [
      {
        "rank": 1,
        "bottleneck": "Audio decode time (CPU-bound)",
        "estimated_impact_ms": 800,
        "percentage_of_total": 53,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:295-296",
        "mitigation": "Implemented: 2-thread decoder pool. Future: Streaming decode (start playback before full buffer filled)."
      },
      {
        "rank": 2,
        "bottleneck": "Resampling overhead (when source != 44.1kHz)",
        "estimated_impact_ms": 200,
        "percentage_of_total": 13,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:306-317",
        "mitigation": "Only applies when resampling needed. Already using rubato (fast resampler). Consider caching resampled audio."
      },
      {
        "rank": 3,
        "bottleneck": "File I/O + codec probe",
        "estimated_impact_ms": 100,
        "percentage_of_total": 7,
        "location": "wkmp-ap/src/audio/decoder.rs",
        "mitigation": "Inherent to symphonia codec detection. Could be cached if passage metadata stored in DB."
      },
      {
        "rank": 4,
        "bottleneck": "Database queries (sequential)",
        "estimated_impact_ms": 100,
        "percentage_of_total": 7,
        "location": "Multiple locations (queue insert, timing load, song timeline)",
        "mitigation": "OPTIMIZATION APPLIED: Parallel initialization queries. Further: Cache passage timing in memory."
      },
      {
        "rank": 5,
        "bottleneck": "Playback loop polling latency (legacy)",
        "estimated_impact_ms": 50,
        "percentage_of_total": 3,
        "location": "wkmp-ap/src/playback/engine.rs:1066",
        "mitigation": "OPTIMIZATION APPLIED: Event-driven buffer notification. Polling still exists but bypassed by event path."
      }
    ]
  },

  "memory_analysis": {
    "ring_buffer_config": {
      "buffer_size_samples": 2048,
      "buffer_size_ms": 46,
      "location": "wkmp-ap/src/playback/ring_buffer.rs:23",
      "notes": "Ring buffer for lock-free audio thread communication. Default 2048 samples @ 44.1kHz = ~46ms"
    },
    "passage_buffer_format": {
      "sample_format": "f32",
      "bytes_per_sample": 4,
      "channels": 2,
      "interleaved": true,
      "location": "wkmp-ap/src/audio/types.rs:17-31",
      "notes": "Stereo interleaved f32 samples. Memory = sample_count × 2 channels × 4 bytes"
    },
    "buffer_strategy": {
      "current_passage": "full_decode",
      "next_passage": "full_decode",
      "queued_passages": "partial_decode_15s",
      "location": "wkmp-ap/src/playback/buffer_manager.rs:39-42",
      "notes": "Full decode for current/next, 15s partial for queued. Minimizes memory while enabling instant crossfade."
    },
    "memory_estimation_per_passage": {
      "typical_song_3min_full": {
        "duration_s": 180,
        "sample_count": 7938000,
        "memory_bytes": 63504000,
        "memory_mb": 60.5,
        "notes": "3-minute song fully decoded: 180s × 44100 Hz × 2 channels × 4 bytes = ~60 MB"
      },
      "partial_buffer_15s": {
        "duration_s": 15,
        "sample_count": 661500,
        "memory_bytes": 5292000,
        "memory_mb": 5.0,
        "notes": "15-second partial buffer: 15s × 44100 Hz × 2 channels × 4 bytes = ~5 MB"
      },
      "first_passage_500ms": {
        "duration_s": 0.5,
        "sample_count": 22050,
        "memory_bytes": 176400,
        "memory_mb": 0.17,
        "notes": "First-passage instant startup buffer: 500ms × 44100 Hz × 2 channels × 4 bytes = ~172 KB"
      }
    },
    "total_buffer_memory_typical": {
      "scenario": "1 current (full) + 1 next (full) + 3 queued (15s each)",
      "current_mb": 60.5,
      "next_mb": 60.5,
      "queued_mb": 15.0,
      "total_mb": 136.0,
      "notes": "Typical steady-state: ~136 MB for 5 passages in various decode states"
    },
    "memory_optimizations": {
      "reserve_capacity": {
        "description": "Pre-allocate buffer capacity to reduce reallocations",
        "location": "wkmp-ap/src/audio/types.rs:118-121",
        "impact": "Reduces memory fragmentation and allocation overhead during decode"
      },
      "incremental_append": {
        "description": "Decode in chunks, append incrementally to enable early playback start",
        "location": "wkmp-ap/src/audio/types.rs:108-113",
        "impact": "Allows playback to start before full decode completes"
      }
    }
  },

  "threading_model": {
    "type": "mixed",
    "async_runtime": "tokio",
    "blocking_threads": "std::thread for decoder workers",
    "components": {
      "main_async_runtime": {
        "description": "Tokio async runtime for API server, engine orchestration, event handling",
        "thread_pool_size": "default (CPU core count)",
        "location": "wkmp-ap/src/main.rs"
      },
      "decoder_pool": {
        "description": "Fixed 2-thread pool for parallel audio decoding",
        "thread_count": 2,
        "location": "wkmp-ap/src/playback/decoder_pool.rs:94-129",
        "rationale": "SSD-DEC-030 - Optimized for Raspberry Pi Zero2W resource limits (4 cores, limited RAM). 2 threads balance decode parallelism with memory pressure.",
        "worker_implementation": "std::thread (blocking I/O + CPU decode)",
        "coordination": "Priority queue + condvar for work distribution"
      },
      "audio_output_thread": {
        "description": "Real-time audio callback thread (cpal)",
        "thread_count": 1,
        "priority": "real_time (OS-scheduled)",
        "location": "wkmp-ap/src/audio/output.rs:212-237",
        "notes": "Managed by cpal/OS. Must be lock-free to avoid dropouts."
      }
    },
    "lock_contention_analysis": {
      "hot_path_locks": [
        {
          "lock": "Arc<Mutex<f32>> for volume",
          "location": "wkmp-ap/src/audio/output.rs:255",
          "frequency": "every audio callback (~100 Hz @ 256 sample buffer)",
          "risk": "low",
          "notes": "Mutex used in real-time audio thread. Potential for priority inversion, but volume changes are rare."
        },
        {
          "lock": "Arc<RwLock<PassageBuffer>> for buffer access",
          "location": "wkmp-ap/src/playback/buffer_manager.rs:24",
          "frequency": "decoder writes (continuous), mixer reads (every frame)",
          "risk": "medium",
          "notes": "RwLock allows concurrent reads but blocks on write. Incremental append minimizes write hold time."
        },
        {
          "lock": "Arc<AtomicU64> for frame position",
          "location": "wkmp-ap/src/playback/engine.rs:44",
          "frequency": "every playback loop iteration (~100 Hz)",
          "risk": "none",
          "notes": "ISSUE-8 optimization: Lock-free atomic for position tracking"
        }
      ]
    },
    "concurrency_optimizations": {
      "event_driven_notification": {
        "description": "PERF-POLL-010 - Replace polling with mpsc event channel for buffer readiness",
        "location": "wkmp-ap/src/playback/buffer_manager.rs:90-136",
        "impact": "Eliminates 0-100ms polling latency"
      },
      "parallel_initialization": {
        "description": "PERF-INIT-010 - Load settings from DB in parallel using tokio::join!",
        "location": "wkmp-ap/src/playback/engine.rs:140 (referenced in STARTUP_OPTIMIZATION_IMPLEMENTATION.md)",
        "impact": "Reduces init time from sum(queries) to max(query)"
      }
    }
  },

  "optimizations_applied": {
    "startup_optimizations": [
      {
        "id": "PERF-START-010",
        "name": "Configurable minimum buffer threshold",
        "status": "implemented",
        "description": "Database setting 'minimum_buffer_threshold_ms' allows tuning startup latency vs. underrun risk",
        "default_value_ms": 3000,
        "recommended_value_ms": 500,
        "range_ms": [500, 5000],
        "location": "wkmp-ap/src/db/settings.rs:249-279",
        "impact": "Potential 3000ms → 500ms startup time reduction for first passage"
      },
      {
        "id": "PERF-FIRST-010",
        "name": "First-passage instant startup",
        "status": "implemented",
        "description": "Use 500ms buffer threshold for very first passage, then revert to configured threshold",
        "location": "wkmp-ap/src/playback/buffer_manager.rs:93-100",
        "impact": "Guaranteed <1s startup for first playback on idle system"
      },
      {
        "id": "PERF-POLL-010",
        "name": "Event-driven buffer readiness notification",
        "status": "implemented",
        "description": "Replace 100ms polling loop with mpsc event channel notification when buffer reaches threshold",
        "location": "wkmp-ap/src/playback/buffer_manager.rs:131-135",
        "impact": "Eliminates 0-100ms polling latency jitter"
      },
      {
        "id": "PERF-INIT-010",
        "name": "Parallel initialization queries",
        "status": "implemented",
        "description": "Load engine settings from database in parallel using tokio::join!",
        "location": "Referenced in STARTUP_OPTIMIZATION_IMPLEMENTATION.md:303",
        "impact": "Reduces init sequence from ~300ms (serial) to ~50ms (parallel)"
      }
    ],
    "performance_tradeoffs": {
      "minimum_buffer_threshold": {
        "lower_value": {
          "pros": "Faster startup, instant playback response",
          "cons": "Higher risk of underruns if decode falls behind playback"
        },
        "higher_value": {
          "pros": "Smoother playback, buffer absorbs decode hiccups",
          "cons": "Longer startup delay, poor UX for instant play"
        },
        "recommendation": "Use 500ms for desktop/modern hardware, 1500-3000ms for Raspberry Pi Zero2W"
      }
    }
  },

  "test_files_available": [
    {
      "path": "/home/sw/Music/Bigger,_Better,_Faster,_More/(4_Non_Blondes)Bigger,_Better,_Faster,_More-02-Superfly_.mp3",
      "format": "mp3",
      "sample_rate": 44100,
      "channels": 2,
      "duration_seconds": 277.58,
      "file_size_mb": 5.9,
      "notes": "Perfect test file - already at 44.1kHz, no resampling needed"
    },
    {
      "path": "/home/sw/Music/Bigger,_Better,_Faster,_More/(4_Non_Blondes)Bigger,_Better,_Faster,_More-03-What's_Up_.mp3",
      "format": "mp3",
      "sample_rate": 44100,
      "channels": 2,
      "duration_seconds": 270.0,
      "file_size_mb": 5.8,
      "notes": "Another 44.1kHz MP3 for consistency testing"
    },
    {
      "path": "/home/sw/Music/Bigger,_Better,_Faster,_More/(4_Non_Blondes)Bigger,_Better,_Faster,_More-04-Pleasantly_Blue_.mp3",
      "format": "mp3",
      "sample_rate": 44100,
      "channels": 2,
      "duration_seconds": 150.0,
      "file_size_mb": 3.0,
      "notes": "Shorter file for rapid iteration testing"
    }
  ],

  "bottleneck_summary": [
    "Audio decode time (800ms) - CPU-bound, 53% of startup delay",
    "Resampling overhead (200ms) - Only when source != 44.1kHz, 13% of delay",
    "File I/O + codec probe (100ms) - Inherent to symphonia, 7% of delay",
    "Database queries (100ms total) - PARTIALLY OPTIMIZED via parallel queries",
    "Minimum buffer threshold - OPTIMIZED: Event-driven + configurable + first-passage 500ms"
  ],

  "next_steps_for_live_testing": [
    {
      "step": 1,
      "action": "Build wkmp-ap binary",
      "command": "cd /home/sw/Dev/McRhythm && cargo build --package wkmp-ap --release",
      "notes": "Use release build for accurate performance measurements"
    },
    {
      "step": 2,
      "action": "Start wkmp-ap server",
      "command": "cd /home/sw/Dev/McRhythm && WKMP_DB_PATH=/home/sw/Music/wkmp.db ./target/release/wkmp-ap",
      "notes": "Run in foreground to monitor logs"
    },
    {
      "step": 3,
      "action": "Verify server health",
      "command": "curl http://localhost:5721/health",
      "expected": "{\"status\":\"ok\",\"module\":\"wkmp-ap\",\"version\":\"...\"}"
    },
    {
      "step": 4,
      "action": "Configure minimum buffer for instant startup",
      "command": "sqlite3 /home/sw/Music/wkmp.db \"INSERT OR REPLACE INTO settings (key, value) VALUES ('minimum_buffer_threshold_ms', '500');\"",
      "notes": "Set to 500ms for desktop performance"
    },
    {
      "step": 5,
      "action": "Enqueue test file",
      "command": "curl -X POST http://localhost:5721/playback/enqueue -H 'Content-Type: application/json' -d '{\"file_path\":\"/home/sw/Music/Bigger,_Better,_Faster,_More/(4_Non_Blondes)Bigger,_Better,_Faster,_More-02-Superfly_.mp3\"}'",
      "notes": "Measure time from request to first audio sample"
    },
    {
      "step": 6,
      "action": "Measure startup latency",
      "method": "Manual timing with stopwatch OR instrumentation via tracing spans",
      "metrics": [
        "Time from API request to first audio output",
        "Decode time for first 500ms of audio",
        "Event notification latency (buffer ready → mixer start)"
      ]
    },
    {
      "step": 7,
      "action": "Run benchmark suite",
      "command": "cd /home/sw/Dev/McRhythm/wkmp-ap && cargo bench --bench crossfade_bench",
      "notes": "Crossfade performance benchmarks using criterion"
    }
  ],

  "performance_targets": {
    "startup_latency": {
      "current_estimate_ms": 1500,
      "target_desktop_ms": 500,
      "target_raspberry_pi_ms": 1500,
      "measurement_method": "Time from POST /playback/enqueue response to first audio callback with non-zero samples"
    },
    "decode_throughput": {
      "target": "Real-time or faster (1.0x minimum, 2.0x preferred)",
      "notes": "Must decode faster than playback to fill buffers. 2x provides headroom for underrun recovery."
    },
    "memory_footprint": {
      "target_desktop_mb": 200,
      "target_raspberry_pi_mb": 150,
      "current_estimate_mb": 136,
      "status": "within target"
    },
    "cpu_usage": {
      "target_idle_percent": 5,
      "target_decode_percent": 50,
      "target_playback_percent": 10,
      "notes": "During active decode: 50% CPU acceptable. During playback only: <10%."
    }
  },

  "references": {
    "analysis_documents": [
      "/home/sw/Dev/McRhythm/wkmp-ap/STARTUP_PERFORMANCE_ANALYSIS.md",
      "/home/sw/Dev/McRhythm/wkmp-ap/STARTUP_OPTIMIZATION_IMPLEMENTATION.md",
      "/home/sw/Dev/McRhythm/wkmp-ap/STARTUP_DIAGNOSTICS.md",
      "/home/sw/Dev/McRhythm/wkmp-ap/TEST_COVERAGE_ASSESSMENT.md"
    ],
    "implementation_files": [
      "/home/sw/Dev/McRhythm/wkmp-ap/src/playback/engine.rs",
      "/home/sw/Dev/McRhythm/wkmp-ap/src/playback/decoder_pool.rs",
      "/home/sw/Dev/McRhythm/wkmp-ap/src/playback/buffer_manager.rs",
      "/home/sw/Dev/McRhythm/wkmp-ap/src/db/settings.rs",
      "/home/sw/Dev/McRhythm/wkmp-ap/src/audio/types.rs"
    ]
  }
}
