{
  "metadata": {
    "generated_date": "2025-10-19",
    "agent": "Agent 3: Technical Contradiction Detector",
    "phase": "Phase 2 - Contradiction Analysis",
    "source_documents": [
      "SPEC016-decoder_buffer_design.md",
      "SPEC017-sample_rate_conversion.md"
    ],
    "analyzed_documents": [
      "SPEC013-single_stream_playback.md",
      "SPEC014-single_stream_design.md",
      "SPEC015-playback_completion_fixes.md",
      "SPEC011-event_system.md",
      "REV004-incremental_buffer_implementation.md",
      "IMPL001-database_schema.md"
    ],
    "total_contradictions_found": 11,
    "critical_contradictions": 3,
    "major_contradictions": 5,
    "minor_contradictions": 3
  },

  "contradictions_by_severity": {
    "CRITICAL": [
      {
        "id": "CONTRA-001",
        "concept": "Decoder Threading Model - Serial vs Parallel",
        "severity": "CRITICAL",
        "category": "Behavioral Contradiction",

        "spec016_statement": {
          "requirement_id": "DBD-DEC-040",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 177,
          "text": "Decoding is handled serially in priority order, only one decode runs at a time to preserve cache coherency and reduce maximum processor loads, to avoid spinning up the cooling fans.",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "SPEC013-single_stream_playback.md",
            "requirement_id": "SSP-DEC-020",
            "line": 81,
            "text": "Technology: symphonia 0.5.x: Pure Rust audio decoder, rubato 0.15.x: High-quality sample rate conversion",
            "tier": "Tier 2",
            "context": "Component diagram shows 'Decoder Thread Pool' with multiple decoder instances (Decoder 1, 2, 3) running in parallel"
          },
          {
            "document": "SPEC014-single_stream_design.md",
            "requirement_id": "SSD-DEC-030",
            "line": 114,
            "text": "Pool Sizing: Fixed pool: 2 decoder threads. Rationale: Sufficient for current + next passage full decode",
            "tier": "Tier 2",
            "context": "Explicitly states 2 decoder threads running concurrently"
          },
          {
            "document": "REV004-incremental_buffer_implementation.md",
            "line": 64,
            "text": "SSD-DEC-030: Fixed 2-thread decoder pool for resource constraints",
            "tier": "Tier R"
          }
        ],

        "resolution_strategy": "SPEC016 describes serial decode execution (one at a time), but SPEC013/SPEC014/REV004 all consistently describe a 2-thread decoder pool with parallel execution. Resolution: SPEC016 needs to be updated to match the implemented 2-thread pool architecture. Update DBD-DEC-040 to clarify that while decodes are prioritized, up to 2 can run concurrently.",

        "auto_editable": true,
        "recommended_action": "Update DBD-DEC-040 in SPEC016 to: 'Decoding is handled by a fixed 2-thread pool in priority order. Up to 2 decodes can run concurrently to enable current + next passage preparation while maintaining manageable processor loads on resource-constrained devices.'",

        "impact_analysis": "HIGH - This affects core playback architecture assumptions. Serial execution would significantly increase latency for queue prefetching. The 2-thread model is correct and already implemented."
      },

      {
        "id": "CONTRA-002",
        "concept": "Fade Application Timing - Pre-buffer vs On-read",
        "severity": "CRITICAL",
        "category": "Architectural Contradiction",

        "spec016_statement": {
          "requirement_id": "DBD-FADE-030",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 199,
          "text": "When fade-in duration is > 0 then samples between the start time and the fade-in end point have the fade-in curve applied before they are buffered.",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "SPEC013-single_stream_playback.md",
            "requirement_id": "SSP-BUF-020",
            "line": 114,
            "text": "Key Features: Automatic fade application during read_sample() - no separate fade step",
            "tier": "Tier 2",
            "context": "PassageBuffer applies fades dynamically when samples are read, not when buffered"
          },
          {
            "document": "SPEC013-single_stream_playback.md",
            "line": 143,
            "text": "// Read sample with fades automatically applied\nlet (left, right) = buffer.read_sample();",
            "tier": "Tier 2",
            "context": "API example shows fades applied at read time"
          },
          {
            "document": "SPEC014-single_stream_design.md",
            "requirement_id": "SSD-FADE-012",
            "line": 205,
            "text": "Fade application can occur during decode or be deferred to read-time (implementation choice)",
            "tier": "Tier 2",
            "context": "Acknowledges both options are possible"
          }
        ],

        "resolution_strategy": "SPEC016 states fades are applied BEFORE buffering (during decode). SPEC013 states fades are applied during read_sample() (after buffering). SPEC014 acknowledges both approaches are valid. Resolution: Determine which is actually implemented, then update SPEC016 to match reality or clarify both approaches are supported.",

        "auto_editable": true,
        "recommended_action": "Update DBD-FADE-030, DBD-FADE-040, DBD-FADE-050 in SPEC016 to clarify: 'Fade curves MAY be applied during decode (pre-buffer) OR during buffer read (on-read). The implementation choice depends on performance trade-offs. On-read application enables dynamic fade adjustment but requires per-sample multiplication. Pre-buffer application pre-computes fades but makes fade parameters immutable.'",

        "impact_analysis": "HIGH - This affects whether fades can be changed after buffering, memory usage patterns, and CPU overhead during playback. Critical for understanding system behavior."
      },

      {
        "id": "CONTRA-003",
        "concept": "Buffer Management Strategy - Full vs Partial Decode",
        "severity": "CRITICAL",
        "category": "Architectural Contradiction",

        "spec016_statement": {
          "requirement_id": "DBD-OV-020",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 19,
          "text": "Separate buffers are created for each [ENT-MP-030] passage.",
          "tier": "Tier 2",
          "context": "No mention of partial buffering or minimum thresholds"
        },

        "conflicting_statements": [
          {
            "document": "SPEC014-single_stream_design.md",
            "requirement_id": "SSD-PBUF-010",
            "line": 193,
            "text": "Queued Passages (After Next) - Partial Buffer Strategy (Configurable): Passages in the queue AFTER the next-to-be-played position are partially decoded to obtain a short buffer of audio ready to be played immediately. Default: 15-second buffer (configurable)",
            "tier": "Tier 2"
          },
          {
            "document": "SPEC014-single_stream_design.md",
            "requirement_id": "SSD-FBUF-010",
            "line": 187,
            "text": "Currently Playing or Next-to-Play Passage - Full Decode Strategy: When a passage is in the currently playing OR next-to-be-played position in the queue, the ENTIRE passage is completely decoded",
            "tier": "Tier 2"
          },
          {
            "document": "REV004-incremental_buffer_implementation.md",
            "line": 119,
            "text": "Solution: Implemented incremental buffer filling per [SSD-PBUF-028]: 1. Decoder appends 1-second chunks progressively, 2. Buffer manager tracks decode progress, 3. Playback starts when minimum threshold (3000ms) met",
            "tier": "Tier R"
          }
        ],

        "resolution_strategy": "SPEC016 does not describe the full vs partial buffer strategy at all. SPEC014 clearly documents two distinct buffering approaches based on queue position. REV004 describes the incremental implementation. Resolution: SPEC016 needs major updates to document both strategies and when each applies.",

        "auto_editable": true,
        "recommended_action": "Add new sections to SPEC016 describing: 1) Full decode strategy for current/next passages (DBD-BUF-070), 2) Partial decode strategy with 15-second default for queued passages (DBD-BUF-080), 3) Minimum playback threshold of 3 seconds (DBD-BUF-090), 4) Incremental buffer filling with 1-second chunks (DBD-BUF-100)",

        "impact_analysis": "CRITICAL - This is a major architectural feature completely missing from SPEC016. Without this, the document does not accurately describe how the system actually works."
      }
    ],

    "MAJOR": [
      {
        "id": "CONTRA-004",
        "concept": "Decoder Pool Sizing - 12 vs 2 Threads",
        "severity": "MAJOR",
        "category": "Value Mismatch",

        "spec016_statement": {
          "requirement_id": "DBD-PARAM-050",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 104,
          "text": "maximum_decode_streams: The maximum number of audio decoders that will operate on passages in the queue. Default value: 12",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "SPEC014-single_stream_design.md",
            "requirement_id": "SSD-DEC-030",
            "line": 114,
            "text": "Pool Sizing: Fixed pool: 2 decoder threads. Rationale: Sufficient for current + next passage full decode (SSD-FBUF-010)",
            "tier": "Tier 2"
          }
        ],

        "resolution_strategy": "SPEC016 says 12 decoder streams, SPEC014 says 2 decoder threads. These concepts are different but confusingly named. Resolution: Clarify that 'maximum_decode_streams' refers to how many passages can have buffers allocated (12), while actual decoder threads are limited to 2 for parallel execution.",

        "auto_editable": true,
        "recommended_action": "Update DBD-PARAM-050 in SPEC016 to clarify: 'maximum_decode_streams determines how many decoder-buffer chains can exist simultaneously (default: 12). Note: Actual decoder execution is limited to a fixed 2-thread pool (see DBD-DEC-040). This parameter controls memory allocation, not thread count.'",

        "impact_analysis": "MEDIUM - Confusion between buffer allocation limit vs actual thread count. Both values are likely correct for their respective purposes."
      },

      {
        "id": "CONTRA-005",
        "concept": "Decode Work Period - 5000ms vs Priority Queue",
        "severity": "MAJOR",
        "category": "Behavioral Contradiction",

        "spec016_statement": {
          "requirement_id": "DBD-PARAM-060",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 111,
          "text": "decode_work_period: The number of wall clock milliseconds between decode job priority evaluation. Default value: 5000ms. Behavior: Once every decode_work_period the currently working decoder is paused and the list of pending decode jobs is evaluated to determine the highest priority job and switch to decoding it.",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "SPEC014-single_stream_design.md",
            "requirement_id": "SSD-DEC-032",
            "line": 124,
            "text": "Priority Queue Management: Implementation: Ordered VecDeque<DecodeRequest>. Insertion: Insert at position based on priority value. Dequeue: Always pop front (highest priority first)",
            "tier": "Tier 2",
            "context": "Describes priority-based queue processing, not time-based switching"
          },
          {
            "document": "SPEC014-single_stream_design.md",
            "line": 88,
            "text": "enum DecodePriority { Immediate, Next, Prefetch }",
            "tier": "Tier 2",
            "context": "Shows enum-based priority, not time-based scheduling"
          }
        ],

        "resolution_strategy": "SPEC016 describes time-based decode switching (pause every 5 seconds to re-evaluate). SPEC014 describes priority queue with continuous processing. Resolution: Determine if decode_work_period is actually implemented or if the priority queue approach replaced it.",

        "auto_editable": true,
        "recommended_action": "If priority queue is implemented: Update DBD-PARAM-060 to describe priority-based scheduling instead of time-based. If decode_work_period is used: Update SPEC014 to document how it integrates with priority queue.",

        "impact_analysis": "MEDIUM - Affects understanding of how decoder threads are scheduled and how priorities are enforced."
      },

      {
        "id": "CONTRA-006",
        "concept": "Component Architecture - Decoder + Resampler + Fade Handler vs Decoder Thread Pool",
        "severity": "MAJOR",
        "category": "Architectural Contradiction",

        "spec016_statement": {
          "requirement_id": "DBD-OV-040",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 23,
          "text": "A simplified view of the audio processing chain is: [mermaid diagram showing Decoder → Resampler → Fade In/Out Handler → Buffer → Mixer → Output]",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "SPEC013-single_stream_playback.md",
            "line": 30,
            "text": "Component Diagram: Decoder Thread Pool → Passage Buffer Manager → Crossfade Mixer → Audio Output Thread",
            "tier": "Tier 2",
            "context": "Shows different component breakdown - no explicit Resampler or Fade Handler components"
          },
          {
            "document": "SPEC014-single_stream_design.md",
            "line": 69,
            "text": "pub struct DecoderPool { workers: Vec<DecoderWorker>, work_queue: Arc<RwLock<VecDeque<DecodeRequest>>>, buffer_manager: Arc<PassageBufferManager> }",
            "tier": "Tier 2",
            "context": "Shows DecoderPool structure with no separate Resampler or Fade Handler components"
          }
        ],

        "resolution_strategy": "SPEC016 shows pipeline as separate components (Decoder, Resampler, Fade Handler). SPEC013/SPEC014 show higher-level architecture (DecoderPool, BufferManager). Resolution: Clarify that SPEC016 shows logical processing steps while SPEC013/SPEC014 show physical component structure. Resampler and Fade Handler are implemented within DecoderPool workers.",

        "auto_editable": true,
        "recommended_action": "Add clarification to SPEC016 DBD-OV-040: 'Note: This diagram shows logical processing stages. In the implemented architecture, Decoder, Resampler, and Fade In/Out Handler are all performed within DecoderPool worker threads (see SPEC014-single_stream_design.md for component-level architecture).'",

        "impact_analysis": "MEDIUM - Creates confusion about system structure. Both views are correct at different levels of abstraction but need to be explicitly linked."
      },

      {
        "id": "CONTRA-007",
        "concept": "Buffer Completion Detection - Position vs Decode Sentinel",
        "severity": "MAJOR",
        "category": "Behavioral Contradiction",

        "spec016_statement": {
          "requirement_id": "DBD-BUF-060",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 219,
          "text": "When the sample corresponding to the passage end time is removed from the buffer, the buffer informs the queue that passage playout has completed; the passage should now be removed from the queue.",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "SPEC015-playback_completion_fixes.md",
            "requirement_id": "PCF-COMP-010",
            "line": 183,
            "text": "Solution: Use explicit 'decode complete' signal instead of comparing position to growing buffer. Add decode_complete (bool) and total_frames (Option<usize>) fields to PassageBuffer.",
            "tier": "Tier 2"
          },
          {
            "document": "SPEC015-playback_completion_fixes.md",
            "line": 204,
            "text": "pub fn is_exhausted(&self, current_position: usize) -> bool { if let Some(total) = self.total_frames { current_position >= total } else { false } }",
            "tier": "Tier 2"
          }
        ],

        "resolution_strategy": "SPEC016 implies completion is detected by position reaching end. SPEC015 explicitly documents using a decode_complete sentinel flag with total_frames to avoid race conditions. Resolution: Update SPEC016 to document the sentinel-based approach.",

        "auto_editable": true,
        "recommended_action": "Update DBD-BUF-060 in SPEC016 to: 'When the mixer position reaches total_frames (set when decoder marks buffer as complete), the buffer is considered exhausted and the passage is removed from the queue. This sentinel-based approach prevents race conditions with incremental buffer filling.'",

        "impact_analysis": "MEDIUM - Important for correctness but SPEC015 already documents the fix. SPEC016 just needs to be updated to reflect the solution."
      },

      {
        "id": "CONTRA-008",
        "concept": "Event System - BufferStateChanged vs Missing",
        "severity": "MAJOR",
        "category": "Missing Integration",

        "spec016_statement": {
          "requirement_id": "DBD-BUF-050",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 217,
          "text": "Whenever the buffer has playout_ringbuffer_headroom or fewer samples of available free space (is nearly full), the decoder is told to pause decoding until more than playout_ringbuffer_headroom samples are available.",
          "tier": "Tier 2",
          "context": "Describes buffer state transitions but no mention of events"
        },

        "conflicting_statements": [
          {
            "document": "SPEC011-event_system.md",
            "requirement_id": "BufferStateChanged",
            "line": 232,
            "text": "BufferStateChanged event with old_state, new_state, passage_id, buffer_status, decode_progress_percent. BufferStatus enum: Decoding, Ready, Playing, Exhausted",
            "tier": "Tier 2"
          },
          {
            "document": "SPEC014-single_stream_design.md",
            "requirement_id": "SSD-BUF-020",
            "line": 308,
            "text": "Event Integration: The Passage Buffer Manager emits BufferStateChanged events at four key transition points: None → Decoding, Decoding → Ready, Ready → Playing, Playing → Exhausted",
            "tier": "Tier 2"
          }
        ],

        "resolution_strategy": "SPEC016 describes buffer state management but doesn't mention the BufferStateChanged event system documented in SPEC011 and SPEC014. Resolution: Add event emission points to SPEC016 buffer lifecycle descriptions.",

        "auto_editable": true,
        "recommended_action": "Add new requirement DBD-BUF-070 to SPEC016: 'The buffer manager emits BufferStateChanged events (see SPEC011-event_system.md) at each state transition: None→Decoding when decoder starts, Decoding→Ready when decode completes, Ready→Playing when mixer starts reading, Playing→Exhausted when position reaches total_frames.'",

        "impact_analysis": "MEDIUM - Not a contradiction per se, but SPEC016 is incomplete without documenting event integration. Important for understanding system observability."
      }
    ],

    "MINOR": [
      {
        "id": "CONTRA-009",
        "concept": "Terminology - 'decoder-buffer chain' vs 'passage buffer' vs 'managed buffer'",
        "severity": "MINOR",
        "category": "Terminology Mismatch",

        "spec016_statement": {
          "requirement_id": "DBD-OV-050",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 60,
          "text": "The system allocates maximum_decode_streams decoder-buffer chains. Each chain is assigned 1:1 to a passage in the queue.",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "SPEC013-single_stream_playback.md",
            "line": 145,
            "text": "Implementation: wkmp-ap/src/playback/pipeline/single_stream/buffer.rs - PassageBuffer",
            "tier": "Tier 2",
            "context": "Uses 'PassageBuffer' terminology"
          },
          {
            "document": "REV004-incremental_buffer_implementation.md",
            "line": 177,
            "text": "buffers.insert(passage_id, ManagedBuffer { buffer: Arc::clone(&buffer_arc), status: BufferStatus::Decoding, decode_started: Instant::now() })",
            "tier": "Tier R",
            "context": "Uses 'ManagedBuffer' terminology"
          }
        ],

        "resolution_strategy": "SPEC016 uses 'decoder-buffer chain', implementation uses 'PassageBuffer' and 'ManagedBuffer'. Resolution: Add terminology cross-reference to clarify these are the same concept with different names at different abstraction levels.",

        "auto_editable": true,
        "recommended_action": "Add glossary note to SPEC016: 'Terminology: decoder-buffer chain (design concept) = PassageBuffer (core data structure) wrapped in ManagedBuffer (lifecycle management). See SPEC013 for implementation details.'",

        "impact_analysis": "LOW - Terminology inconsistency but meaning is clear from context. Just needs cross-reference for clarity."
      },

      {
        "id": "CONTRA-010",
        "concept": "Database Settings - Missing Audio Configuration Parameters",
        "severity": "MINOR",
        "category": "Missing Integration",

        "spec016_statement": {
          "requirement_id": "DBD-PARAM-010",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 78,
          "text": "These defined values are stored in the global settings table of the database, where they are read once at startup for run-time use.",
          "tier": "Tier 2"
        },

        "conflicting_statements": [
          {
            "document": "IMPL001-database_schema.md",
            "line": 750,
            "text": "Settings table Audio Configuration: volume_level (REAL, default 0.5), audio_sink (TEXT, default 'default')",
            "tier": "Tier 3",
            "context": "Database schema documents settings not mentioned in SPEC016"
          },
          {
            "document": "IMPL001-database_schema.md",
            "line": 753,
            "text": "Event Timing Configuration: position_event_interval_ms (INTEGER, 1000), playback_progress_interval_ms (INTEGER, 5000)",
            "tier": "Tier 3"
          }
        ],

        "resolution_strategy": "IMPL001 documents additional settings (volume_level, audio_sink, event intervals) not mentioned in SPEC016. Resolution: Add cross-reference to IMPL001 for complete settings list, or add these settings to SPEC016.",

        "auto_editable": true,
        "recommended_action": "Add note to DBD-PARAM-010 in SPEC016: 'See IMPL001-database_schema.md for complete settings table schema including volume_level, audio_sink, and event timing configuration not directly related to decode/buffer behavior.'",

        "impact_analysis": "LOW - SPEC016 focuses on decode/buffer parameters. Volume and events are handled elsewhere. Just needs cross-reference."
      },

      {
        "id": "CONTRA-011",
        "concept": "Mixer Behavior - Output Ringbuffer Refill vs Lock-Free Ring Buffer",
        "severity": "MINOR",
        "category": "Architectural Contradiction",

        "spec016_statement": {
          "requirement_id": "DBD-MIX-020",
          "document": "SPEC016-decoder_buffer_design.md",
          "line": 225,
          "text": "Every output_refill_period refills the output ring buffer for cpal to output.",
          "tier": "Tier 2",
          "context": "Implies periodic timer-based refill"
        },

        "conflicting_statements": [
          {
            "document": "SPEC013-single_stream_playback.md",
            "requirement_id": "SSP-OUT-050",
            "line": 260,
            "text": "Threading Model: 1. Mixer Thread: Pulls samples from CrossfadeMixer, writes to ring buffer, 2. Audio Callback: Reads from ring buffer, sends to audio device, 3. Synchronization: Lock-free ring buffer with atomic read/write pointers",
            "tier": "Tier 2",
            "context": "Implies continuous lock-free operation, not periodic timer"
          }
        ],

        "resolution_strategy": "SPEC016 implies timer-based periodic refill. SPEC013 describes continuous lock-free operation. Resolution: Clarify that output_refill_period determines how frequently the mixer thread wakes to check buffer level, not a hard timer.",

        "auto_editable": true,
        "recommended_action": "Update DBD-MIX-020 in SPEC016 to: 'The mixer thread wakes approximately every output_refill_period to check output ring buffer fill level and refill as needed. The ring buffer itself uses lock-free atomic operations for continuous audio callback access.'",

        "impact_analysis": "LOW - Both descriptions are compatible. Just needs clarification that periodic check doesn't block continuous audio output."
      }
    ]
  },

  "summary_by_tier": {
    "tier_2_conflicts": {
      "count": 11,
      "auto_editable": true,
      "description": "All conflicts are between Tier 2 documents (SPEC016/SPEC017 vs other SPEC documents). All are auto-editable.",
      "documents": [
        "SPEC013-single_stream_playback.md",
        "SPEC014-single_stream_design.md",
        "SPEC015-playback_completion_fixes.md",
        "SPEC011-event_system.md"
      ]
    },
    "tier_3_minor_gaps": {
      "count": 1,
      "description": "Minor integration gaps with IMPL001 database schema (Tier 3). Settings documented in database but not in SPEC016.",
      "documents": ["IMPL001-database_schema.md"]
    },
    "tier_r_informational": {
      "count": 0,
      "description": "REV004 corroborates SPEC014 contradictions but doesn't introduce new conflicts (Tier R is historical)",
      "documents": ["REV004-incremental_buffer_implementation.md"]
    }
  },

  "top_5_critical_issues": [
    {
      "rank": 1,
      "id": "CONTRA-001",
      "summary": "Decoder Threading: Serial (SPEC016) vs 2-Thread Pool (SPEC014)",
      "impact": "Fundamental architectural mismatch. SPEC016 incorrectly describes serial execution.",
      "priority": "CRITICAL - Must fix"
    },
    {
      "rank": 2,
      "id": "CONTRA-002",
      "summary": "Fade Application: Pre-buffer (SPEC016) vs On-read (SPEC013)",
      "impact": "Affects whether fades are mutable after buffering, CPU overhead, memory patterns.",
      "priority": "CRITICAL - Needs investigation and clarification"
    },
    {
      "rank": 3,
      "id": "CONTRA-003",
      "summary": "Buffer Strategy: Missing partial buffer documentation in SPEC016",
      "impact": "SPEC016 completely missing the full vs partial buffer architecture. Major omission.",
      "priority": "CRITICAL - Must document"
    },
    {
      "rank": 4,
      "id": "CONTRA-004",
      "summary": "Decoder Sizing: 12 streams (SPEC016) vs 2 threads (SPEC014)",
      "impact": "Confusion between buffer allocation limit and thread count. Both may be correct but unclear.",
      "priority": "MAJOR - Needs clarification"
    },
    {
      "rank": 5,
      "id": "CONTRA-005",
      "summary": "Decode Scheduling: Time-based switching (SPEC016) vs Priority queue (SPEC014)",
      "impact": "Contradictory descriptions of how decoder threads are scheduled.",
      "priority": "MAJOR - Needs resolution"
    }
  ],

  "tier_0_1_conflicts_requiring_approval": [],

  "notes": [
    "No Tier 0 or Tier 1 conflicts found - all contradictions are within Tier 2 (design specifications).",
    "SPEC016/SPEC017 appear to be newer design documents that don't fully align with earlier SPEC013/SPEC014.",
    "REV004 provides historical context showing incremental buffer implementation - corroborates SPEC014.",
    "Most contradictions can be resolved by updating SPEC016/SPEC017 to match the implemented architecture documented in SPEC013/SPEC014.",
    "Critical contradictions (CONTRA-001, CONTRA-002, CONTRA-003) represent major architectural discrepancies requiring immediate attention.",
    "Some 'contradictions' are actually different levels of abstraction (e.g., logical pipeline vs component structure) - these need cross-referencing, not conflict resolution."
  ],

  "recommendations": [
    "Priority 1: Update SPEC016 DBD-DEC-040 to document 2-thread decoder pool (replaces serial execution description).",
    "Priority 2: Clarify fade application timing in SPEC016 - determine if pre-buffer or on-read is implemented, document both as options if flexible.",
    "Priority 3: Add full vs partial buffer strategy documentation to SPEC016 (major omission).",
    "Priority 4: Add cross-references between SPEC016 logical pipeline and SPEC013/SPEC014 component architecture.",
    "Priority 5: Document BufferStateChanged event integration in SPEC016.",
    "General: Consider merging overlapping content from SPEC013/SPEC014 into SPEC016/SPEC017 to create single authoritative source for decoder-buffer design."
  ]
}
