# Phase 1 Implementation Plan: Basic Integrity Instrumentation

**Status:** Ready to Implement
**Estimated Time:** 2-3 days
**Goal:** Add end-to-end sample counting and validation

---

## Summary of Current State

### ✅ Already Instrumented

1. **DecoderChain** (`wkmp-ap/src/playback/pipeline/decoder_chain.rs:72`)
   ```rust
   total_frames_pushed: usize  // Incremented in process_chunk() at line 267
   pub fn total_frames_pushed(&self) -> usize { ... }  // Getter at line 319
   ```

2. **PlayoutRingBuffer** (`wkmp-ap/src/playback/playout_ring_buffer.rs`)
   ```rust
   total_frames_written: AtomicU64  // Line 135, updated at line 253
   total_frames_read: AtomicU64     // Line 139, updated at line 315
   pub fn get_statistics(&self) -> BufferStatistics { ... }  // Line 434
   ```

### ❌ Missing Instrumentation

1. **CrossfadeMixer** (`wkmp-ap/src/playback/pipeline/mixer.rs`)
   - Has per-passage `frame_count` in state machine (line 187)
   - **Missing:** Global `total_frames_mixed: AtomicU64` counter

2. **Diagnostics Module**
   - No `wkmp-ap/src/playback/diagnostics.rs` module
   - No validation logic to compare counters
   - No metrics aggregation API

---

## Implementation Steps

### Step 1: Add Mixer Frame Counter (30 minutes)

**File:** `/home/sw/Dev/McRhythm/wkmp-ap/src/playback/pipeline/mixer.rs`

**Modification 1:** Add field to `CrossfadeMixer` struct (after line 141):

```rust
/// Total frames mixed since mixer creation (monotonic counter)
/// Used for end-to-end sample integrity validation
/// **[PHASE1-INTEGRITY]** Incremented on every get_next_frame() call
/// Ordering: Relaxed (statistics only)
total_frames_mixed: AtomicU64,
```

**Modification 2:** Import AtomicU64 in use statements (line 40):

```rust
use std::sync::atomic::{AtomicU64, Ordering};
```

**Modification 3:** Initialize in `new()` method (after line 220):

```rust
total_frames_mixed: AtomicU64::new(0),
```

**Modification 4:** Increment in `get_next_frame()` method (at line 587, right after `self.frame_counter += 1;`):

```rust
// **[PHASE1-INTEGRITY]** Track total frames mixed for validation
self.total_frames_mixed.fetch_add(1, Ordering::Relaxed);
```

**Modification 5:** Add getter method (after line 869):

```rust
/// Get total frames mixed since mixer creation
///
/// **[PHASE1-INTEGRITY]** Used for end-to-end sample integrity validation
///
/// # Returns
/// Total number of frames generated by get_next_frame() (includes silence during pause)
pub fn get_total_frames_mixed(&self) -> u64 {
    self.total_frames_mixed.load(Ordering::Relaxed)
}
```

**Acceptance Criteria:**
- Code compiles without errors
- Counter increments on every `get_next_frame()` call
- Getter accessible from engine

---

### Step 2: Create Diagnostics Module (1-2 hours)

**File:** `/home/sw/Dev/McRhythm/wkmp-ap/src/playback/diagnostics.rs` (NEW FILE)

```rust
//! Pipeline diagnostics and validation
//!
//! Provides end-to-end sample integrity validation by comparing counters
//! from decoder, buffer, and mixer stages.
//!
//! **[PHASE1-INTEGRITY]** Basic sample counting validation

use std::collections::HashMap;
use uuid::Uuid;

/// Aggregated pipeline metrics for one passage
#[derive(Debug, Clone)]
pub struct PassageMetrics {
    pub passage_id: Uuid,
    pub decoder_frames_pushed: usize,
    pub buffer_frames_written: u64,
    pub buffer_frames_read: u64,
}

/// Global pipeline metrics
#[derive(Debug, Clone)]
pub struct PipelineMetrics {
    pub passages: HashMap<Uuid, PassageMetrics>,
    pub mixer_total_frames_mixed: u64,
}

/// Validation result
#[derive(Debug, Clone, PartialEq)]
pub enum ValidationResult {
    /// All counters match within tolerance
    Healthy,

    /// Counters diverge but within warning threshold
    Warning {
        message: String,
        details: HashMap<String, u64>
    },

    /// Counters diverge beyond acceptable limits
    Error {
        message: String,
        details: HashMap<String, u64>
    },
}

impl PipelineMetrics {
    /// Validate pipeline integrity
    ///
    /// **Validation Rules:**
    /// 1. decoder_frames × 2 ≈ buffer_frames_written (±tolerance)
    /// 2. buffer_frames_written ≥ buffer_frames_read (FIFO invariant)
    /// 3. buffer_frames_read ≤ mixer_total_frames_mixed (mixer reads from buffer)
    ///
    /// # Arguments
    /// * `tolerance_samples` - Acceptable difference in sample counts (default: 8192)
    ///
    /// # Returns
    /// ValidationResult indicating health status
    pub fn validate(&self, tolerance_samples: u64) -> ValidationResult {
        let mut details = HashMap::new();

        // Sum all passages
        let total_decoder_frames: u64 = self.passages.values()
            .map(|p| p.decoder_frames_pushed as u64)
            .sum();
        let total_buffer_written: u64 = self.passages.values()
            .map(|p| p.buffer_frames_written)
            .sum();
        let total_buffer_read: u64 = self.passages.values()
            .map(|p| p.buffer_frames_read)
            .sum();

        details.insert("decoder_frames".to_string(), total_decoder_frames);
        details.insert("buffer_written".to_string(), total_buffer_written);
        details.insert("buffer_read".to_string(), total_buffer_read);
        details.insert("mixer_frames".to_string(), self.mixer_total_frames_mixed);

        // Rule 1: Decoder output should equal buffer writes (frames → samples stereo)
        let expected_buffer_writes = total_decoder_frames * 2; // Stereo
        let buffer_write_diff = (expected_buffer_writes as i64 - total_buffer_written as i64).abs() as u64;

        if buffer_write_diff > tolerance_samples {
            return ValidationResult::Error {
                message: format!(
                    "Decoder→Buffer mismatch: decoded {} frames ({} samples stereo), but buffer has {} samples written (diff: {})",
                    total_decoder_frames, expected_buffer_writes, total_buffer_written, buffer_write_diff
                ),
                details,
            };
        }

        // Rule 2: Buffer writes ≥ buffer reads (FIFO invariant)
        if total_buffer_written < total_buffer_read {
            return ValidationResult::Error {
                message: format!(
                    "Buffer invariant violation: written {} < read {} (impossible with FIFO)",
                    total_buffer_written, total_buffer_read
                ),
                details,
            };
        }

        // Rule 3: Mixer frames should approximately match buffer reads
        // Note: Mixer counts frames (stereo pairs), buffer counts samples
        let expected_mixer_frames = total_buffer_read / 2; // Convert samples to frames
        let mixer_frame_diff = (expected_mixer_frames as i64 - self.mixer_total_frames_mixed as i64).abs() as u64;

        if mixer_frame_diff > (tolerance_samples / 2) {
            return ValidationResult::Warning {
                message: format!(
                    "Buffer→Mixer mismatch: buffer read {} samples ({} frames), but mixer mixed {} frames (diff: {} frames)",
                    total_buffer_read, expected_mixer_frames, self.mixer_total_frames_mixed, mixer_frame_diff
                ),
                details,
            };
        }

        ValidationResult::Healthy
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_healthy() {
        let passage_id = Uuid::new_v4();
        let mut passages = HashMap::new();
        passages.insert(passage_id, PassageMetrics {
            passage_id,
            decoder_frames_pushed: 44100,  // 1 second @ 44.1kHz
            buffer_frames_written: 88200,  // 44100 frames * 2 channels
            buffer_frames_read: 88200,     // All consumed
        });

        let metrics = PipelineMetrics {
            passages,
            mixer_total_frames_mixed: 44100, // Same as decoder frames
        };

        let result = metrics.validate(8192);
        assert_eq!(result, ValidationResult::Healthy);
    }

    #[test]
    fn test_validate_decoder_buffer_mismatch() {
        let passage_id = Uuid::new_v4();
        let mut passages = HashMap::new();
        passages.insert(passage_id, PassageMetrics {
            passage_id,
            decoder_frames_pushed: 44100,
            buffer_frames_written: 50000, // Way off!
            buffer_frames_read: 50000,
        });

        let metrics = PipelineMetrics {
            passages,
            mixer_total_frames_mixed: 25000,
        };

        let result = metrics.validate(8192);
        match result {
            ValidationResult::Error { message, .. } => {
                assert!(message.contains("Decoder→Buffer mismatch"));
            }
            _ => panic!("Expected Error, got {:?}", result),
        }
    }
}
```

**Modification to module tree:** Add to `/home/sw/Dev/McRhythm/wkmp-ap/src/playback/mod.rs`:

```rust
pub mod diagnostics;
```

**Acceptance Criteria:**
- Module compiles and unit tests pass
- Validation logic correctly identifies healthy/error cases
- Tolerance thresholds reasonable (±8192 samples = ~0.18s @ 44.1kHz stereo)

---

### Step 3: Add Engine API for Metrics (30 minutes)

**File:** `/home/sw/Dev/McRhythm/wkmp-ap/src/playback/engine.rs`

**Modification 1:** Import diagnostics module (add to use statements):

```rust
use crate::playback::diagnostics::{PipelineMetrics, PassageMetrics};
```

**Modification 2:** Add method to PlaybackEngine (after line ~800):

```rust
/// Get aggregated pipeline metrics for validation
///
/// **[PHASE1-INTEGRITY]** Collects counters from decoder, buffer, mixer
///
/// # Returns
/// PipelineMetrics containing all counter values
pub async fn get_pipeline_metrics(&self) -> Result<PipelineMetrics> {
    let mut passages = std::collections::HashMap::new();

    // Collect buffer statistics for all passages
    let buffer_stats = self.buffer_manager.get_all_statistics().await;

    for (passage_id, buffer_stat) in buffer_stats {
        passages.insert(passage_id, PassageMetrics {
            passage_id,
            decoder_frames_pushed: 0, // TODO: Get from decoder_chain tracking
            buffer_frames_written: buffer_stat.total_written,
            buffer_frames_read: buffer_stat.total_read,
        });
    }

    // Get mixer total
    let mixer_total = self.mixer.lock().await.get_total_frames_mixed();

    Ok(PipelineMetrics {
        passages,
        mixer_total_frames_mixed: mixer_total,
    })
}
```

**Note:** This requires `BufferManager::get_all_statistics()` method. Add to `buffer_manager.rs`:

```rust
/// Get statistics for all buffers
pub async fn get_all_statistics(&self) -> HashMap<Uuid, BufferStatistics> {
    let buffers = self.buffers.read().await;
    buffers.iter()
        .map(|(id, buf)| (*id, buf.get_statistics()))
        .collect()
}
```

**Acceptance Criteria:**
- Engine API callable from test harness
- Returns valid metrics structure
- No panics or deadlocks

---

### Step 4: Create Test File Generator (1 hour)

**File:** `/home/sw/Dev/McRhythm/wkmp-ap/tests/utils/audio_generator.rs` (NEW FILE)

```rust
//! Test audio file generation utilities
//!
//! **[PHASE1-INTEGRITY]** Generate deterministic test files for validation

use std::path::Path;
use uuid::Uuid;

/// Metadata for a generated test file
#[derive(Debug, Clone)]
pub struct AudioFileMetadata {
    pub path: String,
    pub duration_secs: f64,
    pub sample_rate: u32,
    pub channels: u16,
    pub total_frames: u64,
    pub total_samples: u64, // frames * channels
}

/// Generate a silent WAV file
///
/// # Arguments
/// * `duration_secs` - Duration in seconds
/// * `sample_rate` - Sample rate (44100 for non-resampled testing)
/// * `output_path` - Where to write the file
///
/// # Returns
/// Metadata about the generated file
pub fn generate_silent_wav(
    duration_secs: f64,
    sample_rate: u32,
    output_path: &Path,
) -> Result<AudioFileMetadata, String> {
    use hound::{WavSpec, WavWriter};

    let channels = 2u16;
    let spec = WavSpec {
        channels,
        sample_rate,
        bits_per_sample: 16,
        sample_format: hound::SampleFormat::Int,
    };

    let mut writer = WavWriter::create(output_path, spec)
        .map_err(|e| format!("Failed to create WAV file: {}", e))?;

    let total_frames = (duration_secs * sample_rate as f64) as u64;
    let total_samples = total_frames * channels as u64;

    // Write zeros (silence)
    for _ in 0..total_samples {
        writer.write_sample(0i16)
            .map_err(|e| format!("Failed to write sample: {}", e))?;
    }

    writer.finalize()
        .map_err(|e| format!("Failed to finalize WAV: {}", e))?;

    Ok(AudioFileMetadata {
        path: output_path.to_string_lossy().to_string(),
        duration_secs,
        sample_rate,
        channels,
        total_frames,
        total_samples,
    })
}

/// Generate a sine wave WAV file
///
/// # Arguments
/// * `frequency_hz` - Sine wave frequency (e.g., 440.0 for A4)
/// * `duration_secs` - Duration in seconds
/// * `sample_rate` - Sample rate
/// * `output_path` - Where to write the file
///
/// # Returns
/// Metadata about the generated file
pub fn generate_sine_wav(
    frequency_hz: f64,
    duration_secs: f64,
    sample_rate: u32,
    output_path: &Path,
) -> Result<AudioFileMetadata, String> {
    use hound::{WavSpec, WavWriter};
    use std::f64::consts::PI;

    let channels = 2u16;
    let spec = WavSpec {
        channels,
        sample_rate,
        bits_per_sample: 16,
        sample_format: hound::SampleFormat::Int,
    };

    let mut writer = WavWriter::create(output_path, spec)
        .map_err(|e| format!("Failed to create WAV file: {}", e))?;

    let total_frames = (duration_secs * sample_rate as f64) as u64;
    let amplitude = 0.5; // 50% amplitude to avoid clipping

    // Generate sine wave (stereo = same signal on both channels)
    for frame in 0..total_frames {
        let t = frame as f64 / sample_rate as f64;
        let sample_value = amplitude * (2.0 * PI * frequency_hz * t).sin();
        let sample_i16 = (sample_value * i16::MAX as f64) as i16;

        // Write both channels
        writer.write_sample(sample_i16)
            .map_err(|e| format!("Failed to write sample: {}", e))?;
        writer.write_sample(sample_i16)
            .map_err(|e| format!("Failed to write sample: {}", e))?;
    }

    writer.finalize()
        .map_err(|e| format!("Failed to finalize WAV: {}", e))?;

    let total_samples = total_frames * channels as u64;

    Ok(AudioFileMetadata {
        path: output_path.to_string_lossy().to_string(),
        duration_secs,
        sample_rate,
        channels,
        total_frames,
        total_samples,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_silent_wav() {
        let temp_path = PathBuf::from("/tmp/test_silent_1s.wav");
        let metadata = generate_silent_wav(1.0, 44100, &temp_path).unwrap();

        assert_eq!(metadata.total_frames, 44100);
        assert_eq!(metadata.total_samples, 88200);
        assert!(temp_path.exists());

        // Cleanup
        std::fs::remove_file(temp_path).ok();
    }

    #[test]
    fn test_generate_sine_wav() {
        let temp_path = PathBuf::from("/tmp/test_sine_440hz_1s.wav");
        let metadata = generate_sine_wav(440.0, 1.0, 44100, &temp_path).unwrap();

        assert_eq!(metadata.total_frames, 44100);
        assert_eq!(metadata.total_samples, 88200);
        assert!(temp_path.exists());

        // Cleanup
        std::fs::remove_file(temp_path).ok();
    }
}
```

**Create module file:** `/home/sw/Dev/McRhythm/wkmp-ap/tests/utils/mod.rs`:

```rust
pub mod audio_generator;
```

**Add dependency to Cargo.toml:**

```toml
[dev-dependencies]
hound = "3.5"
```

**Acceptance Criteria:**
- Generator functions create valid WAV files
- Metadata accurate (verified by symphonia decode)
- Files playable by wkmp-ap decoder

---

### Step 5: Create First Integration Test (1 hour)

**File:** `/home/sw/Dev/McRhythm/wkmp-ap/tests/pipeline_integrity_test.rs` (NEW FILE)

```rust
//! Pipeline integrity integration tests
//!
//! **[PHASE1-INTEGRITY]** End-to-end sample counting validation

mod utils;

use utils::audio_generator::{generate_silent_wav, AudioFileMetadata};
use std::path::PathBuf;
use std::time::Duration;

const TEST_TIMEOUT: Duration = Duration::from_secs(30);
const TOLERANCE_SAMPLES: u64 = 8192; // ~0.18s @ 44.1kHz stereo

/// Helper: Create test engine with minimal configuration
///
/// TODO: Implement based on engine.rs initialization
/// Should use in-memory database or temporary database
async fn create_test_engine() -> wkmp_ap::playback::engine::PlaybackEngine {
    todo!("Initialize engine for testing")
}

/// Helper: Wait for playback completion
///
/// TODO: Listen for PlaybackFinished event or poll engine status
async fn wait_for_completion(/* event receiver */) -> Result<(), String> {
    tokio::time::timeout(TEST_TIMEOUT, async {
        // Poll or listen for completion
        todo!()
    })
    .await
    .map_err(|_| "Test timeout".to_string())?
}

#[tokio::test]
async fn test_silent_1s_playback_integrity() {
    // Generate 1-second silent file
    let temp_path = PathBuf::from("/tmp/test_integrity_silent_1s.wav");
    let fixture = generate_silent_wav(1.0, 44100, &temp_path)
        .expect("Failed to generate test file");

    // Initialize engine
    let engine = create_test_engine().await;

    // Enqueue and play
    engine.enqueue(&PathBuf::from(&fixture.path)).await
        .expect("Failed to enqueue");
    engine.play().await.expect("Failed to play");

    // Wait for completion
    wait_for_completion().await.expect("Playback failed");

    // Collect metrics
    let metrics = engine.get_pipeline_metrics().await
        .expect("Failed to get metrics");

    // Validate
    let validation = metrics.validate(TOLERANCE_SAMPLES);

    match validation {
        wkmp_ap::playback::diagnostics::ValidationResult::Healthy => {
            println!("✓ Pipeline integrity validated");
        }
        wkmp_ap::playback::diagnostics::ValidationResult::Warning { message, details } => {
            eprintln!("⚠ Warning: {}", message);
            eprintln!("Details: {:?}", details);
            panic!("Pipeline integrity warning (treat as error in tests)");
        }
        wkmp_ap::playback::diagnostics::ValidationResult::Error { message, details } => {
            eprintln!("✗ Error: {}", message);
            eprintln!("Details: {:?}", details);
            panic!("Pipeline integrity validation failed");
        }
    }

    // Cleanup
    std::fs::remove_file(temp_path).ok();
}

// TODO: Add more tests:
// - test_sine_5s_playback_integrity()
// - test_multiple_files_queue_integrity()
// - test_pause_resume_integrity()
```

**Acceptance Criteria:**
- Test compiles
- Test helper functions implemented (create_test_engine, wait_for_completion)
- First test passes with healthy validation
- Clear error messages on validation failure

---

## Next Actions

1. **Implement Step 1-2 first:** Mixer counter + diagnostics module (foundation)
2. **Test manually:** Use developer UI to verify counters updating
3. **Implement Step 3-4:** Engine API + test generator (infrastructure)
4. **Implement Step 5:** First integration test (validation)
5. **Iterate:** Fix any validation failures, refine tolerances

## Success Metrics

- ✅ All code compiles without errors
- ✅ Mixer counter increments on every frame
- ✅ Diagnostics module validates healthy pipeline
- ✅ First integration test passes
- ✅ Clear diagnostic output on validation failure

---

**Estimated Total Time:** 2-3 days (8-12 hours of focused work)

**Files to Create:**
- `wkmp-ap/src/playback/diagnostics.rs`
- `wkmp-ap/tests/utils/mod.rs`
- `wkmp-ap/tests/utils/audio_generator.rs`
- `wkmp-ap/tests/pipeline_integrity_test.rs`
- `docs/validation/IMPLEMENTATION_PLAN_Phase1.md` (this file)

**Files to Modify:**
- `wkmp-ap/src/playback/pipeline/mixer.rs` (add counter)
- `wkmp-ap/src/playback/mod.rs` (add diagnostics module)
- `wkmp-ap/src/playback/engine.rs` (add metrics API)
- `wkmp-ap/src/playback/buffer_manager.rs` (add get_all_statistics)
- `wkmp-ap/Cargo.toml` (add hound dependency)
