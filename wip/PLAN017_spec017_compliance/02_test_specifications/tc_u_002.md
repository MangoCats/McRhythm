# TC-U-002: File Duration Roundtrip

**Test Type:** Unit Test
**Priority:** MEDIUM
**Automation:** Yes (Rust test)
**Requirements:** REQ-F-003

---

## Objective

Verify that file duration conversion from seconds to ticks and back to seconds is mathematically accurate within acceptable floating-point error bounds.

---

## Preconditions

- `wkmp_common::timing::seconds_to_ticks()` function available
- `wkmp_common::timing::ticks_to_seconds()` function available

---

## Test Data

| Input (Seconds) | Expected Ticks | Roundtrip Seconds | Max Error |
|-----------------|----------------|-------------------|-----------|
| 0.5 | 14,112,000 | 0.5 | <1e-9 |
| 5.0 | 141,120,000 | 5.0 | <1e-9 |
| 180.5 | 5,094,432,000 | 180.5 | <1e-9 |
| 0.000001 | 28 | ~0.000001 | <1e-6 |
| 3600.0 | 101,606,400,000 | 3600.0 | <1e-9 |

---

## Test Procedure

### Given
- Conversion functions from wkmp_common::timing module

### When
- For each test value:
  1. Convert seconds (f64) → ticks (i64) via `seconds_to_ticks()`
  2. Verify tick value matches expected
  3. Convert ticks (i64) → seconds (f64) via `ticks_to_seconds()`
  4. Verify roundtrip error < threshold

### Then
- Tick values match expected values exactly
- Roundtrip error within acceptable bounds
- No precision loss for common duration values

---

## Implementation

```rust
#[cfg(test)]
mod file_duration_roundtrip_tests {
    use wkmp_common::timing::{seconds_to_ticks, ticks_to_seconds};

    #[test]
    fn test_duration_roundtrip_accuracy() {
        let test_cases = vec![
            (0.5, 14_112_000_i64),
            (5.0, 141_120_000_i64),
            (180.5, 5_094_432_000_i64),
            (0.000001, 28_i64),  // 1 microsecond
            (3600.0, 101_606_400_000_i64),  // 1 hour
        ];

        for (input_seconds, expected_ticks) in test_cases {
            // Convert seconds → ticks
            let ticks = seconds_to_ticks(input_seconds);
            assert_eq!(
                ticks, expected_ticks,
                "seconds_to_ticks({}) = {}, expected {}",
                input_seconds, ticks, expected_ticks
            );

            // Convert ticks → seconds (roundtrip)
            let roundtrip_seconds = ticks_to_seconds(ticks);
            let error = (roundtrip_seconds - input_seconds).abs();

            // For most values, error should be negligible
            let max_error = if input_seconds < 0.00001 {
                1e-6  // Relaxed for very small values
            } else {
                1e-9  // Strict for normal values
            };

            assert!(
                error < max_error,
                "Roundtrip error for {} seconds: {} (max: {})",
                input_seconds, error, max_error
            );
        }
    }

    #[test]
    fn test_zero_duration() {
        let ticks = seconds_to_ticks(0.0);
        assert_eq!(ticks, 0);

        let seconds = ticks_to_seconds(0);
        assert_eq!(seconds, 0.0);
    }

    #[test]
    fn test_negative_duration_handling() {
        // Negative durations should not occur in practice,
        // but conversion should handle them mathematically
        let ticks = seconds_to_ticks(-5.0);
        assert_eq!(ticks, -141_120_000);

        let seconds = ticks_to_seconds(-141_120_000);
        assert_eq!(seconds, -5.0);
    }
}
```

---

## Pass Criteria

**PASS:**
- All tick conversions match expected values exactly
- All roundtrip errors < threshold
- Zero and negative cases handled correctly

**FAIL:**
- Any tick value mismatch
- Roundtrip error exceeds threshold
- Unexpected panics or errors

---

## Edge Cases Covered

- ✅ Zero duration (empty file)
- ✅ Very small durations (1 microsecond)
- ✅ Common durations (0.5s, 5s, 3 minutes)
- ✅ Large durations (1 hour)
- ✅ Negative durations (theoretical)

---

## Mathematical Verification

**Formula:** `ticks = seconds × 28,224,000`

**Examples:**
- 5.0 seconds × 28,224,000 = 141,120,000 ticks ✓
- 180.5 seconds × 28,224,000 = 5,094,432,000 ticks ✓

**Roundtrip:** `seconds = ticks / 28,224,000`

**Precision:**
- i64 ticks: exact integer representation
- f64 seconds: 53-bit mantissa, ~15 decimal digits
- Error sources: division rounding only

---

## Dependencies

- wkmp_common::timing module
- TICK_RATE = 28,224,000 per SPEC017

---

## Notes

- This test verifies **conversion accuracy**, not database storage (see TC-I-001)
- Roundtrip test ensures no precision loss for typical file durations
- Actual implementation in wkmp_common may already have these tests (timing_tests.rs)
