# TC-I-001: File Import with Tick Duration

**Test Type:** Integration Test
**Priority:** MEDIUM
**Automation:** Yes (Rust integration test)
**Requirements:** REQ-F-003

---

## Objective

Verify that wkmp-ai file import workflow correctly stores file duration as i64 ticks in the database, and that the value can be retrieved and converted back to seconds.

---

## Preconditions

- wkmp.db database with schema updated (duration_ticks INTEGER field)
- Sample audio file available (5-second WAV recommended)
- wkmp-ai import workflow functional
- wkmp_common::timing conversion functions available

---

## Test Data

**Sample Audio File:**
- Format: WAV, 44.1kHz, stereo
- Duration: Exactly 5.0 seconds
- Expected ticks: 141,120,000

---

## Test Procedure

### Given
- Fresh database with updated schema
- 5-second sample audio file at known path

### When
1. Import file via wkmp-ai import workflow
2. Query database for inserted file record

### Then
- `duration_ticks` field contains 141,120,000 (not NULL)
- Converting ticks → seconds yields ~5.0 (within 0.001s error)
- Old `duration` field does NOT exist in schema

---

## Implementation

```rust
#[cfg(test)]
mod file_import_integration_tests {
    use wkmp_common::db::Database;
    use wkmp_common::timing::ticks_to_seconds;
    use std::path::PathBuf;

    #[tokio::test]
    async fn test_file_import_stores_duration_ticks() {
        // Setup: Create temporary database
        let temp_db = create_temp_database().await;
        let db = Database::new(&temp_db).await.unwrap();

        // Import 5-second sample file
        let sample_file = PathBuf::from("test_assets/5sec_sample.wav");
        let import_result = import_audio_file(&db, &sample_file).await;
        assert!(import_result.is_ok(), "Import should succeed");

        // Query database for file record
        let file_id = import_result.unwrap();
        let row = db.query_one(
            "SELECT duration_ticks FROM files WHERE id = ?",
            &[&file_id]
        ).await.unwrap();

        // Verify ticks stored correctly
        let duration_ticks: Option<i64> = row.get("duration_ticks");
        assert!(duration_ticks.is_some(), "duration_ticks should not be NULL");

        let ticks = duration_ticks.unwrap();
        assert_eq!(ticks, 141_120_000, "5 seconds = 141,120,000 ticks");

        // Verify roundtrip to seconds
        let seconds = ticks_to_seconds(ticks);
        assert!((seconds - 5.0).abs() < 0.001, "Roundtrip should yield ~5.0 seconds");
    }

    #[tokio::test]
    async fn test_file_with_unknown_duration() {
        // Test NULL handling: file with unreadable duration metadata
        let temp_db = create_temp_database().await;
        let db = Database::new(&temp_db).await.unwrap();

        // Import file with no duration metadata (or corrupted metadata)
        let sample_file = PathBuf::from("test_assets/no_duration_metadata.wav");
        let import_result = import_audio_file(&db, &sample_file).await;

        // Import should succeed even if duration unknown
        assert!(import_result.is_ok(), "Import with unknown duration should succeed");

        let file_id = import_result.unwrap();
        let row = db.query_one(
            "SELECT duration_ticks FROM files WHERE id = ?",
            &[&file_id]
        ).await.unwrap();

        // Verify NULL stored (not 0)
        let duration_ticks: Option<i64> = row.get("duration_ticks");
        assert!(duration_ticks.is_none(), "Unknown duration should be NULL, not 0");
    }

    #[tokio::test]
    async fn test_old_duration_field_removed() {
        // Verify schema migration: old REAL duration field no longer exists
        let temp_db = create_temp_database().await;
        let db = Database::new(&temp_db).await.unwrap();

        // Query schema
        let result = db.query_one(
            "PRAGMA table_info(files)",
            &[]
        ).await;

        // Parse column names
        let columns: Vec<String> = result.iter()
            .map(|row| row.get::<String>("name"))
            .collect();

        assert!(!columns.contains(&"duration".to_string()),
                "Old 'duration' REAL field should not exist");
        assert!(columns.contains(&"duration_ticks".to_string()),
                "New 'duration_ticks' INTEGER field should exist");
    }
}
```

---

## Pass Criteria

**PASS:**
- File import succeeds
- `duration_ticks` field contains expected value (141,120,000 for 5s file)
- Roundtrip conversion accurate (error < 0.001s)
- Unknown duration files store NULL (not 0)
- Old `duration` REAL field does not exist in schema

**FAIL:**
- Import fails unexpectedly
- `duration_ticks` is NULL for file with known duration
- `duration_ticks` contains incorrect value
- Unknown duration stores 0 instead of NULL
- Old `duration` field still exists

---

## Edge Cases Covered

- ✅ Known duration file (5 seconds)
- ✅ Unknown duration file (NULL handling)
- ✅ Schema verification (old field removed)

---

## Dependencies

- wkmp-ai import workflow (metadata extraction)
- wkmp_common::timing::seconds_to_ticks()
- Database schema with `duration_ticks INTEGER` field
- Test audio assets (5sec_sample.wav, no_duration_metadata.wav)

---

## Breaking Change Verification

**Critical:** This test verifies the breaking change from REQ-F-003:
- Old databases with `duration REAL` will fail (expected)
- New databases with `duration_ticks INTEGER` will pass
- No automated migration path (user must rebuild database)

---

## Notes

- Requires test audio files in `test_assets/` directory
- Integration test (requires actual database and file I/O)
- May take longer than unit tests (metadata extraction overhead)
- Verifies end-to-end: metadata extraction → conversion → storage
