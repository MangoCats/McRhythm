# Test Specification: TC-U-010-02

**Test ID:** TC-U-010-02
**Test Type:** Unit Test (Automated)
**Requirement:** REQ-MIX-010 - Unit Tests for Pre-Faded Sample Reading
**Priority:** P1-High
**Estimated Effort:** 30-45 minutes (write + implement)

---

## Test Objective

Verify that mixer reads pre-faded samples from buffer and applies ONLY master volume (no fade curve calculations).

---

## Test Scope

**Component Under Test:** Mixer mixing logic (single passage playback)

**Specific Behavior:** Mixer reads samples from buffer, multiplies by master volume, outputs result

**What This Tests:**
- ✅ Mixer reads samples from buffer unchanged
- ✅ Mixer applies master volume multiplication
- ✅ Mixer does NOT apply fade curves (samples already faded)
- ✅ Output = `buffer_sample * master_volume`

**What This Does NOT Test:**
- ❌ Crossfade mixing (separate test: TC-U-010-03)
- ❌ Fade curve calculations (should never occur in mixer)
- ❌ Buffer management (assumed functional)

---

## Test Design

### Test Type: Property-Based Unit Test

**Given:** Buffer populated with pre-faded samples (linear ramp 0.0 → 1.0)
**When:** Mixer reads samples with master_volume = 0.8
**Then:** Output = `buffer_sample * 0.8` (no additional fading)

### Test Data

**Input Buffer (10 frames, interleaved stereo):**
```rust
let buffer_samples = vec![
    // Frame 0
    0.0, 0.0,
    // Frame 1
    0.1, 0.1,
    // Frame 2
    0.2, 0.2,
    // Frame 3
    0.3, 0.3,
    // Frame 4
    0.4, 0.4,
    // Frame 5
    0.5, 0.5,
    // Frame 6
    0.6, 0.6,
    // Frame 7
    0.7, 0.7,
    // Frame 8
    0.8, 0.8,
    // Frame 9
    0.9, 0.9,
];
```

**Master Volume:** 0.8

**Expected Output (10 frames, interleaved stereo):**
```rust
let expected_output = vec![
    // Frame 0: 0.0 * 0.8 = 0.0
    0.0, 0.0,
    // Frame 1: 0.1 * 0.8 = 0.08
    0.08, 0.08,
    // Frame 2: 0.2 * 0.8 = 0.16
    0.16, 0.16,
    // Frame 3: 0.3 * 0.8 = 0.24
    0.24, 0.24,
    // Frame 4: 0.4 * 0.8 = 0.32
    0.32, 0.32,
    // Frame 5: 0.5 * 0.8 = 0.4
    0.4, 0.4,
    // Frame 6: 0.6 * 0.8 = 0.48
    0.48, 0.48,
    // Frame 7: 0.7 * 0.8 = 0.56
    0.56, 0.56,
    // Frame 8: 0.8 * 0.8 = 0.64
    0.64, 0.64,
    // Frame 9: 0.9 * 0.8 = 0.72
    0.72, 0.72,
];
```

---

## Test Implementation

### Test Code (Pseudocode)

```rust
#[tokio::test]
async fn test_mixer_reads_prefaded_samples_master_volume() {
    // Setup: Create mixer with master volume 0.8
    let mut mixer = Mixer::new(0.8);

    // Setup: Create mock buffer with pre-faded samples (linear ramp)
    let mut passage_buffer = create_mock_buffer_with_samples(vec![
        0.0, 0.0, 0.1, 0.1, 0.2, 0.2, 0.3, 0.3, 0.4, 0.4,
        0.5, 0.5, 0.6, 0.6, 0.7, 0.7, 0.8, 0.8, 0.9, 0.9,
    ]);

    // Action: Mix samples
    let mut output = vec![0.0_f32; 20]; // 10 stereo frames
    mixer.mix_single(&mut passage_buffer, &mut output).unwrap();

    // Assert: Output matches expected (buffer_sample * master_volume)
    let expected = vec![
        0.0, 0.0, 0.08, 0.08, 0.16, 0.16, 0.24, 0.24, 0.32, 0.32,
        0.4, 0.4, 0.48, 0.48, 0.56, 0.56, 0.64, 0.64, 0.72, 0.72,
    ];

    for (i, (&actual, &expected_val)) in output.iter().zip(expected.iter()).enumerate() {
        assert!(
            (actual - expected_val).abs() < 0.001,
            "Output mismatch at index {}: expected {}, got {}",
            i, expected_val, actual
        );
    }

    // Verify: No fade curve calculations occurred
    // (If mixer applied fade curves, output would NOT match buffer * master_volume)
}
```

### Helper Function (Mock Buffer)

```rust
fn create_mock_buffer_with_samples(samples: Vec<f32>) -> RingBuffer {
    let mut buffer = RingBuffer::new(samples.len());
    for &sample in &samples {
        buffer.push(sample).unwrap();
    }
    buffer
}
```

---

## Pass Criteria

**Test passes if ALL of the following are true:**
1. ✅ All output samples match `buffer_sample * master_volume` within tolerance (±0.001)
2. ✅ Linear relationship maintained (ramp 0.0 → 1.0 becomes ramp 0.0 → 0.72 with master_volume 0.8)
3. ✅ No fade curve applied (output is NOT exponential, cosine, or other non-linear shape)

**Numeric Verification:**
- Output[0] = 0.0 (0.0 * 0.8)
- Output[2] = 0.08 (0.1 * 0.8)
- Output[18] = 0.72 (0.9 * 0.8)

**What This Proves:**
- Mixer does NOT apply fade curves (output is linear, matching input)
- Mixer ONLY applies master volume (constant multiplier 0.8)
- Samples are pre-faded (mixer assumes buffer contains faded samples)

---

## Fail Criteria

**Test fails if ANY of the following are true:**
- ❌ Output samples do NOT match `buffer_sample * master_volume`
- ❌ Non-linear transformation detected (indicates fade curve application)
- ❌ Master volume not applied (output matches buffer exactly)
- ❌ Master volume applied incorrectly (wrong multiplier)

**Examples of Failure:**

**Failure Case 1: Fade Curve Applied**
- If mixer applies exponential fade-in:
  - Output[2] would be ~0.008 (0.1² * 0.8), not 0.08
  - Indicates mixer is applying fade curves (WRONG per SPEC016 [DBD-MIX-042])

**Failure Case 2: Master Volume Not Applied**
- If mixer ignores master volume:
  - Output would match buffer exactly (0.0, 0.1, 0.2, ...)
  - Indicates mixer not applying master volume (WRONG per SPEC016 [DBD-MIX-040])

---

## Dependencies

**Prerequisites:**
- Mixer implementation with `mix_single()` method
- Mock buffer or RingBuffer implementation
- tokio::test runtime

**Mock Requirements:**
- Buffer must support `pop(frames_requested)` returning Vec<f32>
- Buffer must be pre-populated with test data

---

## Architectural Verification

**What This Test Verifies:**

✅ **SPEC016 [DBD-MIX-040] Compliance:**
- "The mixer reads **pre-faded audio samples** from buffers"
- "No runtime fade curve calculations are performed by the mixer"

✅ **SPEC016 [DBD-MIX-042] Compliance:**
- Mixer does NOT apply passage-level fade curves
- Fader component responsibility (BEFORE buffering)
- Mixer only applies master volume (AFTER reading from buffer)

**Architectural Separation:**
- This test would FAIL if mixer applied fade curves
- This test would PASS only if mixer reads pre-faded samples
- Therefore, test enforces architectural separation

---

## Related Tests

**Complementary Tests:**
- **TC-U-010-01:** Mixer API does not accept fade curves (compile-time check)
- **TC-U-010-03:** Crossfade is simple addition (no fade calculations during overlap)
- **TC-I-011-01:** Fader-Buffer-Mixer pipeline (integration, verifies Fader applies curves)

**Test Sequence:**
1. TC-U-010-01: Verify API design (fade curves not in API)
2. **TC-U-010-02: Verify single passage behavior** ← This test
3. TC-U-010-03: Verify crossfade behavior
4. TC-I-011-01: Verify end-to-end pipeline

---

## Notes

**Tolerance:**
- Floating-point comparison tolerance: ±0.001
- Rationale: Accounts for floating-point rounding errors

**Test Data Rationale:**
- Linear ramp (0.0 → 1.0) makes fade curve detection easy
- If mixer applies exponential fade: output would be quadratic, not linear
- If mixer applies cosine fade: output would be S-curve, not linear
- Linear output proves no fade curve applied

**Edge Cases (Separate Tests):**
- Master volume = 0.0 (TC-U-010-06)
- Master volume = 1.0 (no change to samples)
- Master volume clamping (TC-U-010-05)

---

**Test Specification Complete**
**Date:** 2025-01-30
