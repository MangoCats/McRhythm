# Test Specification: TC-I-011-01

**Test ID:** TC-I-011-01
**Test Type:** Integration Test (Automated)
**Requirement:** REQ-MIX-011 - Integration Tests with Fader Component
**Priority:** P1-High
**Estimated Effort:** 45-60 minutes (write + implement + debug)

---

## Test Objective

Verify end-to-end Fader → Buffer → Mixer pipeline: Fader applies fade-in curve BEFORE buffering, Mixer reads pre-faded samples and applies only master volume.

---

## Test Scope

**Components Under Test:**
1. **Fader:** Applies fade-in curve to raw audio samples
2. **Buffer:** Stores pre-faded samples
3. **Mixer:** Reads pre-faded samples, applies master volume

**Integration Points:**
- Fader output → Buffer input (samples are faded)
- Buffer output → Mixer input (samples are pre-faded)

**What This Tests:**
- ✅ Fader applies fade-in curve correctly
- ✅ Buffer stores faded samples (not raw)
- ✅ Mixer reads faded samples (not raw)
- ✅ NO double-fading (samples not faded twice)
- ✅ Architectural separation per [DBD-MIX-042]

**What This Does NOT Test:**
- ❌ Fade-out (separate test: TC-I-011-02)
- ❌ Crossfade overlap (separate test: TC-I-011-03)
- ❌ Fader implementation details (unit tests for Fader)

---

## Test Design

### Test Type: End-to-End Integration Test

**Pipeline Flow:**
```
Raw Audio (constant 1.0)
  ↓
Fader (applies exponential fade-in, 5 frames)
  ↓
Buffer (stores faded samples)
  ↓
Mixer (reads buffer, applies master volume 1.0)
  ↓
Output (should match Fader output, NOT double-faded)
```

### Test Data

**Raw Audio Input (10 frames, constant value):**
```rust
let raw_audio = vec![
    1.0, 1.0,  // Frame 0
    1.0, 1.0,  // Frame 1
    1.0, 1.0,  // Frame 2
    1.0, 1.0,  // Frame 3
    1.0, 1.0,  // Frame 4
    1.0, 1.0,  // Frame 5 (fade complete)
    1.0, 1.0,  // Frame 6
    1.0, 1.0,  // Frame 7
    1.0, 1.0,  // Frame 8
    1.0, 1.0,  // Frame 9
];
```

**Fade Configuration:**
- **Fade Type:** Exponential (quadratic: `position²`)
- **Fade Duration:** 5 frames (0 → 4)
- **Fade Position Calculation:** `frame_index / fade_duration`
- **Fade Multiplier:** `position²` (exponential curve)

**Expected Fader Output (after fade-in applied):**
```rust
// Frame 0: position = 0.0 / 5.0 = 0.0, multiplier = 0.0² = 0.0
// Frame 1: position = 1.0 / 5.0 = 0.2, multiplier = 0.2² = 0.04
// Frame 2: position = 2.0 / 5.0 = 0.4, multiplier = 0.4² = 0.16
// Frame 3: position = 3.0 / 5.0 = 0.6, multiplier = 0.6² = 0.36
// Frame 4: position = 4.0 / 5.0 = 0.8, multiplier = 0.8² = 0.64
// Frame 5+: position = 5.0 / 5.0 = 1.0, multiplier = 1.0² = 1.0 (fade complete)

let faded_samples = vec![
    0.0, 0.0,      // Frame 0: 1.0 * 0.0 = 0.0
    0.04, 0.04,    // Frame 1: 1.0 * 0.04 = 0.04
    0.16, 0.16,    // Frame 2: 1.0 * 0.16 = 0.16
    0.36, 0.36,    // Frame 3: 1.0 * 0.36 = 0.36
    0.64, 0.64,    // Frame 4: 1.0 * 0.64 = 0.64
    1.0, 1.0,      // Frame 5: 1.0 * 1.0 = 1.0
    1.0, 1.0,      // Frame 6
    1.0, 1.0,      // Frame 7
    1.0, 1.0,      // Frame 8
    1.0, 1.0,      // Frame 9
];
```

**Master Volume:** 1.0 (no attenuation)

**Expected Mixer Output (faded_samples * master_volume):**
```rust
// Same as faded_samples (master_volume = 1.0)
let expected_output = vec![
    0.0, 0.0,      // Frame 0
    0.04, 0.04,    // Frame 1
    0.16, 0.16,    // Frame 2
    0.36, 0.36,    // Frame 3
    0.64, 0.64,    // Frame 4
    1.0, 1.0,      // Frame 5
    1.0, 1.0,      // Frame 6
    1.0, 1.0,      // Frame 7
    1.0, 1.0,      // Frame 8
    1.0, 1.0,      // Frame 9
];
```

---

## Test Implementation

### Test Code (Pseudocode)

```rust
#[tokio::test]
async fn test_fader_buffer_mixer_pipeline_fade_in() {
    // Step 1: Create raw audio samples (constant 1.0)
    let raw_audio = vec![1.0_f32; 20]; // 10 stereo frames

    // Step 2: Create Fader with exponential fade-in (5 frames)
    let passage_timing = PassageWithTiming {
        start_time_ticks: 0,
        fade_in_point_ticks: ticks_from_samples(5, 44100), // 5 frames
        end_time_ticks: Some(ticks_from_samples(10, 44100)),
        fade_in_curve: Some(FadeCurve::Exponential),
        // ... other fields
    };
    let mut fader = Fader::new(&passage_timing, 44100, None);

    // Step 3: Apply Fader to raw audio (chunk by chunk)
    let mut faded_samples = Vec::new();
    let chunk_size = 2; // Process 2 samples (1 stereo frame) at a time
    for chunk in raw_audio.chunks(chunk_size) {
        let mut chunk_vec = chunk.to_vec();
        fader.apply_fade_to_chunk(&mut chunk_vec);
        faded_samples.extend_from_slice(&chunk_vec);
    }

    // Step 4: Store faded samples in buffer
    let mut passage_buffer = RingBuffer::new(20);
    for &sample in &faded_samples {
        passage_buffer.push(sample).unwrap();
    }

    // Step 5: Create Mixer with master volume 1.0
    let mut mixer = Mixer::new(1.0);

    // Step 6: Mix samples (read from buffer)
    let mut output = vec![0.0_f32; 20]; // 10 stereo frames
    mixer.mix_single(&mut passage_buffer, &mut output).unwrap();

    // Step 7: Verify output matches Fader output (NOT double-faded)
    let expected = vec![
        0.0, 0.0,      // Frame 0: 0.0² = 0.0
        0.04, 0.04,    // Frame 1: 0.2² = 0.04
        0.16, 0.16,    // Frame 2: 0.4² = 0.16
        0.36, 0.36,    // Frame 3: 0.6² = 0.36
        0.64, 0.64,    // Frame 4: 0.8² = 0.64
        1.0, 1.0,      // Frame 5: 1.0² = 1.0
        1.0, 1.0,      // Frame 6
        1.0, 1.0,      // Frame 7
        1.0, 1.0,      // Frame 8
        1.0, 1.0,      // Frame 9
    ];

    for (i, (&actual, &expected_val)) in output.iter().zip(expected.iter()).enumerate() {
        assert!(
            (actual - expected_val).abs() < 0.01,
            "Output mismatch at index {}: expected {}, got {}",
            i, expected_val, actual
        );
    }

    // Step 8: Verify NO double-fading
    // If mixer applied fade-in AGAIN:
    //   - Frame 1 would be 0.04 * 0.04 = 0.0016 (NOT 0.04)
    //   - Frame 4 would be 0.64 * 0.64 = 0.4096 (NOT 0.64)
    // Since output matches faded_samples, no double-fading occurred
}
```

---

## Pass Criteria

**Test passes if ALL of the following are true:**
1. ✅ Fader output shows exponential fade-in curve (0.0, 0.04, 0.16, 0.36, 0.64, 1.0, ...)
2. ✅ Buffer stores faded samples (matches Fader output)
3. ✅ Mixer output matches faded samples (NOT double-faded)
4. ✅ Output curve is exponential (NOT exponential²)

**Numeric Verification:**
- Frame 0: 0.0 (fade start)
- Frame 1: 0.04 (0.2² × 1.0)
- Frame 2: 0.16 (0.4² × 1.0)
- Frame 3: 0.36 (0.6² × 1.0)
- Frame 4: 0.64 (0.8² × 1.0)
- Frame 5+: 1.0 (fade complete)

**What This Proves:**
- ✅ Fader applies fade-in curve BEFORE buffering
- ✅ Buffer stores pre-faded samples
- ✅ Mixer reads pre-faded samples (no additional fading)
- ✅ Architectural separation maintained per [DBD-MIX-042]

---

## Fail Criteria

**Test fails if ANY of the following are true:**
- ❌ Mixer output does NOT match Fader output (indicates double-fading or other issue)
- ❌ Output curve is exponential² (indicates mixer applied fade AGAIN)
- ❌ Buffer stores raw samples (indicates Fader not applied)
- ❌ Numeric values don't match expected exponential curve

**Double-Fading Detection:**

**How to Detect Double-Fading:**
- **Expected (correct):** Frame 1 = 0.04 (faded once)
- **If double-faded:** Frame 1 = 0.04² = 0.0016 (faded twice)
- **Difference:** 25x difference (0.04 vs. 0.0016)

**Example Failure Case:**
```
Output[2] = 0.0016 (expected 0.04)
Output[6] = 0.0256 (expected 0.16)
Output[10] = 0.1296 (expected 0.36)
→ Indicates mixer applied exponential fade AGAIN (double-fading)
→ VIOLATION of [DBD-MIX-042] (mixer must read pre-faded, not apply fades)
```

---

## Dependencies

**Prerequisites:**
- Fader component implemented and functional
- Buffer (RingBuffer) implemented and functional
- Mixer implemented with `mix_single()` method
- PassageWithTiming struct available
- FadeCurve enum (Exponential variant)
- tokio::test runtime

**External Components:**
- `wkmp-common::timing::ticks_from_samples()` helper
- Fader `apply_fade_to_chunk()` method (or equivalent)

**Mock Requirements:**
- If Fader requires file I/O, mock or stub decoder
- If Buffer requires async operations, use tokio::test

---

## Architectural Verification

**What This Test Verifies:**

✅ **SPEC016 [DBD-MIX-040] Compliance:**
- "Fade-in and fade-out curves have already been applied to samples by the Fader component ([DBD-FADE-030/050]) before buffering"
- "The mixer reads **pre-faded audio samples** from buffers"

✅ **SPEC016 [DBD-MIX-041] Compliance:**
- "Both passages have fade curves already applied to buffered samples"
- "Simple addition - no fade curve calculations needed"

✅ **SPEC016 [DBD-MIX-042] Compliance:**
- **Fader component:** Applies fade curves BEFORE buffering (verified)
- **Buffer component:** Stores pre-faded samples (verified)
- **Mixer component:** Reads pre-faded samples (verified)

**Separation of Concerns:**
- Fader: Responsible for fade curve application (tested here)
- Buffer: Responsible for storage (pass-through, tested here)
- Mixer: Responsible for mixing + master volume (tested here)
- **NO overlap** in responsibilities (each component has distinct role)

---

## Related Tests

**Complementary Tests:**
- **TC-I-011-02:** Fader-Buffer-Mixer pipeline: fade-out (symmetric to this test)
- **TC-I-011-03:** Crossfade overlap with pre-fading (both passages)
- **TC-I-011-04:** No double-fading detection (negative test, explicitly checks for violation)
- **TC-U-010-02:** Mixer reads pre-faded samples (unit test, simpler than this integration test)

**Test Sequence:**
1. **TC-I-011-01: Fade-in pipeline** ← This test
2. TC-I-011-02: Fade-out pipeline
3. TC-I-011-03: Crossfade with pre-fading (combines fade-in + fade-out)
4. TC-I-011-04: Double-fading detection (negative test)

---

## Notes

**Tolerance:**
- Floating-point comparison tolerance: ±0.01
- Rationale: Integration test may have more rounding errors than unit test

**Exponential Curve Math:**
- Fade-in exponential: `multiplier = position²`
- Position at frame N: `N / fade_duration`
- Frame 0: 0/5 = 0.0, multiplier = 0.0
- Frame 1: 1/5 = 0.2, multiplier = 0.04
- Frame 2: 2/5 = 0.4, multiplier = 0.16
- Frame 3: 3/5 = 0.6, multiplier = 0.36
- Frame 4: 4/5 = 0.8, multiplier = 0.64
- Frame 5+: 5/5 = 1.0, multiplier = 1.0

**Why Constant Input?**
- Raw audio = constant 1.0 simplifies verification
- Faded output = fade curve shape (easy to verify)
- If raw audio varied, would need to account for both audio content AND fade curve

**Alternative Test Data:**
- Linear fade-in: easier math (0.0, 0.2, 0.4, 0.6, 0.8, 1.0)
- Cosine fade-in: more complex, but tests different curve
- **Exponential chosen:** Most common fade type, easy to detect double-fading

---

**Test Specification Complete**
**Date:** 2025-01-30
