# TC-S-010-01: End-to-End Multi-Song Import

**Test ID:** TC-S-010-01
**Test Type:** System Test (End-to-End)
**Requirement:** REQ-AI-010 (Per-Song Import Workflow)
**Priority:** Critical Path
**Estimated Effort:** 2 hours (write + implement + test data)

---

## Test Objective

Verify complete end-to-end import workflow for a multi-song audio file, from HTTP request to database records and SSE events.

---

## Test Specification

### Given (Setup)

**Test Environment:**
- wkmp-ai HTTP server running on port 5723
- SQLite database initialized (wkmp.db)
- Test audio file: `test_data/test_album.flac` (3 songs, 10 minutes total)
  - Song 1: 0:00-3:30 (Pink Floyd - "Breathe")
  - Song 2: 3:30-6:45 (Pink Floyd - "On The Run")
  - Song 3: 6:45-10:00 (Pink Floyd - "Time")

**Prerequisites:**
- AcoustID API key configured
- MusicBrainz API accessible
- Test file has valid ID3 tags with embedded MBIDs
- Database `passages` table has new provenance columns

### When (Action)

**Step 1: Initiate Import**
```bash
POST http://localhost:5723/import/start
Content-Type: application/json

{
  "file_path": "/path/to/test_album.flac"
}
```

**Step 2: Monitor SSE Events**
```bash
GET http://localhost:5723/import/events
Accept: text/event-stream
```

### Then (Expected Result)

**Phase 1: SSE Event Stream Verification**

Expected SSE event sequence:

```
1. event: FileImportStarted
   data: {"file_path": "/path/to/test_album.flac"}

2. event: PassagesDiscovered
   data: {"file_path": "/path/to/test_album.flac", "count": 3}

3. event: SongExtracting
   data: {"passage_id": "uuid-1"}

4. event: IdentityResolved
   data: {"passage_id": "uuid-1", "mbid": "...", "confidence": 0.99, "sources": ["AcoustID", "ID3"]}

5. event: MetadataFused
   data: {"passage_id": "uuid-1", "title": "Breathe (In The Air)", "source": "MusicBrainz", "conflicts": []}

6. event: FlavorSynthesized
   data: {"passage_id": "uuid-1", "completeness": 0.85, "sources": {...}}

7. event: ValidationComplete
   data: {"passage_id": "uuid-1", "status": "Pass", "quality_score": 94, "warnings": []}

8. event: SongCompleted
   data: {"passage_id": "uuid-1", "title": "Breathe (In The Air)", "status": "Success"}

[Repeat events 3-8 for passages 2 and 3]

Final event: FileImportComplete
   data: {"file_path": "/path/to/test_album.flac", "summary": {"total": 3, "successes": 3, "warnings": 0, "failures": 0}}
```

**Assertions (SSE):**
```rust
// 1. Verify event count
assert_eq!(sse_events.len(), 1 + 1 + (3 * 6) + 1);  // 21 events total

// 2. Verify event types in correct order
assert_eq!(sse_events[0].event_type, "FileImportStarted");
assert_eq!(sse_events[1].event_type, "PassagesDiscovered");
assert_eq!(sse_events[20].event_type, "FileImportComplete");

// 3. Verify passage count
let passages_discovered: PassagesDiscoveredEvent = serde_json::from_str(&sse_events[1].data)?;
assert_eq!(passages_discovered.count, 3);

// 4. Verify all songs completed successfully
let completion: FileImportCompleteEvent = serde_json::from_str(&sse_events[20].data)?;
assert_eq!(completion.summary.successes, 3);
assert_eq!(completion.summary.failures, 0);
```

---

**Phase 2: Database Record Verification**

```rust
// Query database for created passages
let passages = sqlx::query!("SELECT * FROM passages WHERE file_path = ?", test_file_path)
    .fetch_all(&db_pool)
    .await?;

// 1. Verify 3 passage records created
assert_eq!(passages.len(), 3);

// 2. Verify first passage data
let passage1 = &passages[0];
assert_eq!(passage1.title, Some("Breathe (In The Air)".to_string()));
assert!(passage1.recording_mbid.is_some());  // Identity resolved
assert!(passage1.musical_flavor_json.is_some());  // Flavor synthesized
assert!(passage1.flavor_source_blend.is_some());  // Provenance tracked
assert!(passage1.overall_quality_score.is_some());  // Quality scored

// 3. Verify source provenance fields populated
assert_eq!(passage1.title_source, Some("MusicBrainz".to_string()));
assert!(passage1.title_confidence.unwrap() > 0.85);
assert!(passage1.identity_confidence.unwrap() > 0.90);

// 4. Verify validation fields
assert_eq!(passage1.validation_status, Some("Pass".to_string()));

// 5. Verify import metadata
assert!(passage1.import_session_id.is_some());
assert!(passage1.import_timestamp.is_some());
assert_eq!(passage1.import_strategy, Some("HybridFusion".to_string()));
```

---

**Phase 3: Import Provenance Log Verification**

```rust
// Query import_provenance table
let provenance_entries = sqlx::query!(
    "SELECT * FROM import_provenance WHERE passage_id IN (?, ?, ?)",
    passages[0].id, passages[1].id, passages[2].id
)
.fetch_all(&db_pool)
.await?;

// 1. Verify multiple provenance entries per passage
assert!(provenance_entries.len() >= 9);  // At least 3 sources × 3 passages

// 2. Verify source types present
let source_types: HashSet<_> = provenance_entries.iter()
    .map(|e| e.source_type.clone())
    .collect();
assert!(source_types.contains("ID3"));
assert!(source_types.contains("AcoustID"));
assert!(source_types.contains("MusicBrainz"));

// 3. Verify confidence scores stored
for entry in &provenance_entries {
    assert!(entry.confidence.is_some());
    assert!(entry.confidence.unwrap() >= 0.0 && entry.confidence.unwrap() <= 1.0);
}
```

---

**Phase 4: Musical Flavor Validation**

```rust
// Parse musical flavor JSON for each passage
for passage in &passages {
    let flavor_json = passage.musical_flavor_json.as_ref().unwrap();
    let flavor: HashMap<String, f64> = serde_json::from_str(flavor_json)?;

    // 1. Verify normalization: characteristics sum to 1.0 (per category)
    let danceability_sum: f64 = flavor.iter()
        .filter(|(k, _)| k.starts_with("danceability"))
        .map(|(_, v)| v)
        .sum();
    assert!((danceability_sum - 1.0).abs() < 0.0001, "Danceability not normalized");

    // 2. Verify source blend tracked
    let source_blend_json = passage.flavor_source_blend.as_ref().unwrap();
    let source_blend: Vec<String> = serde_json::from_str(source_blend_json)?;
    assert!(!source_blend.is_empty(), "Source blend empty");

    // 3. Verify completeness score reasonable
    let completeness = passage.flavor_completeness.unwrap();
    assert!(completeness > 0.5 && completeness <= 1.0, "Completeness unreasonable: {}", completeness);
}
```

---

## Pass Criteria

**Test passes if ALL of the following are true:**

**SSE Events:**
1. ✅ 21 events emitted in correct order
2. ✅ PassagesDiscovered event shows count=3
3. ✅ 3 complete per-song event cycles (SongExtracting → SongCompleted)
4. ✅ FileImportComplete event shows 3 successes, 0 failures

**Database Records:**
5. ✅ 3 passage records created in `passages` table
6. ✅ All passages have non-NULL: recording_mbid, musical_flavor_json, title
7. ✅ All provenance fields populated (title_source, identity_confidence, etc.)
8. ✅ All validation fields populated (validation_status, overall_quality_score)
9. ✅ Import metadata fields populated (import_session_id, import_timestamp, import_strategy)

**Import Provenance:**
10. ✅ At least 9 entries in `import_provenance` table (3 sources × 3 passages minimum)
11. ✅ Source types include ID3, AcoustID, MusicBrainz
12. ✅ All entries have confidence scores 0.0-1.0

**Data Quality:**
13. ✅ Musical flavor characteristics normalized (sum to 1.0 ± 0.0001 per category)
14. ✅ Completeness scores > 0.5 for all passages
15. ✅ Quality scores > 80 for all passages (clean test data)

**Test fails if:**
- ❌ Any passage missing from database
- ❌ Any provenance field NULL (title_source, identity_confidence, etc.)
- ❌ Musical flavor not normalized
- ❌ SSE events out of order or missing
- ❌ Import provenance table empty

---

## Test Data Requirements

**Test Audio File:** `test_data/test_album.flac`
- Multi-song FLAC file (3 distinct songs)
- Clear silence between songs (for boundary detection)
- ID3 tags with embedded MusicBrainz MBIDs (known-good data)
- Songs exist in MusicBrainz database
- Songs have AcousticBrainz data (pre-2022 recordings)

**Recommended Test Album:** Pink Floyd - Dark Side of the Moon (subset)
- Well-known, well-documented in MusicBrainz
- High-quality AcousticBrainz data available
- Clear song boundaries

---

## Environment Setup

**Before Test:**
```bash
# 1. Start wkmp-ai server
cargo run -p wkmp-ai &

# 2. Initialize test database
sqlite3 wkmp.db < migrations/up.sql

# 3. Set environment variables
export ACOUSTID_API_KEY="test-api-key-here"
export WKMP_ROOT_FOLDER="/tmp/wkmp_test"

# 4. Copy test audio file
cp test_data/test_album.flac /tmp/wkmp_test/
```

**After Test:**
```bash
# Cleanup
pkill wkmp-ai
rm /tmp/wkmp_test/wkmp.db
```

---

## Performance Expectations

**Expected Duration:**
- Passage detection: ~5 seconds
- Per-song processing: ~30-60 seconds each (network API calls)
- Total import time: ~2-4 minutes for 3 songs

**If test takes >10 minutes:** FAIL (performance regression)

---

## Traceability

**Requirement:** REQ-AI-010 (Per-Song Import Workflow) - Line 74
**Also Verifies:**
- REQ-AI-011 (Passage boundary detection)
- REQ-AI-012 (Per-song processing)
- REQ-AI-070 through REQ-AI-073 (SSE events)
- REQ-AI-080 through REQ-AI-087 (Database schema)

**Related Tests:**
- TC-I-012-01 (Integration test for per-song workflow)
- TC-S-012-01 (System test with error cases)

---

## Status

- [ ] Test Specification Written
- [ ] Test Data Prepared
- [ ] Test Implemented
- [ ] Test Passing
- [ ] Performance Verified

**Last Updated:** 2025-01-08
