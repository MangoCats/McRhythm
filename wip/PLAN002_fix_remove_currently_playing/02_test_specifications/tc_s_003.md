# TC-S-003: Remove Currently Playing Passage, Then Enqueue New

**Test ID:** TC-S-003
**Type:** System Test (End-to-End)
**Requirements:** REQ-FIX-070 (Prevent resume), REQ-FIX-080 (New passage starts)
**Priority:** Critical
**Estimated Effort:** 15 minutes to write + implement

---

## Test Objective

Verify that removing the currently playing passage and then enqueuing a new passage results in the NEW passage playing, not the removed passage resuming. This is the exact bug scenario reported.

---

## Test Scenario

**Given:**
- wkmp-ap server running
- Empty queue initially
- Test audio file A available at known path
- Test audio file B available at known path (different from A)

**When:**
1. Enqueue passage A via HTTP POST `/playback/enqueue`
2. Wait for playback to start (verify via SSE `PlaybackStateChanged` event)
3. Remove passage A via HTTP DELETE `/playback/queue/{queue_entry_id_A}`
4. Wait 1 second (ensure cleanup complete)
5. Enqueue passage B via HTTP POST `/playback/enqueue`

**Then:**
1. Passage A stops immediately on removal (step 3)
2. Queue becomes empty after removal (step 3)
3. Playback stops after removal (step 3)
4. Passage B starts playing when enqueued (step 5)
5. Passage A does **NOT** resume at any point
6. Passage B is the only audio output after step 5

---

## Detailed Test Steps

### Setup
```
1. Start wkmp-ap in test mode
2. Create test audio files:
   - test_passage_a.mp3 (2-second audio, identifiable tone/content)
   - test_passage_b.mp3 (2-second audio, DIFFERENT from A)
3. Connect SSE client to /events
4. Clear any existing queue entries
```

### Execution
```
5. POST /playback/enqueue
   Body: { "file_path": "/path/to/test_passage_a.mp3", "timestamp": T, "hash": H }
   Expected Response: 200 OK, returns queue_entry_id_A

6. Wait for SSE event: PlaybackStateChanged { state: "Playing" }
   Expected: Event received within 500ms

7. Verify passage A is playing:
   - GET /playback/state → state: "Playing"
   - GET /playback/queue → queue: [{ queue_entry_id: A, file_path: "...a.mp3" }]

8. DELETE /playback/queue/{queue_entry_id_A}
   Expected Response: 204 No Content

9. Wait for SSE events:
   - QueueStateUpdate { queue: [] }
   - PlaybackStateChanged { state: "Stopped" }
   Expected: Events received within 500ms

10. Verify playback stopped and queue empty:
    - GET /playback/state → state: "Stopped"
    - GET /playback/queue → queue: []

11. Wait 1000ms (ensure all cleanup complete)

12. POST /playback/enqueue
    Body: { "file_path": "/path/to/test_passage_b.mp3", "timestamp": T, "hash": H }
    Expected Response: 200 OK, returns queue_entry_id_B

13. Wait for SSE event: PlaybackStateChanged { state: "Playing" }
    Expected: Event received within 500ms

14. Verify passage B is playing (NOT passage A):
    - GET /playback/state → state: "Playing"
    - GET /playback/queue → queue: [{ queue_entry_id: B, file_path: "...b.mp3" }]
    - Audio output matches passage B content (not passage A)

15. Wait for passage B to finish naturally
    Expected: PlaybackStateChanged { state: "Stopped" } after ~2 seconds
```

### Teardown
```
16. Stop wkmp-ap
17. Clean up test audio files
```

---

## Pass Criteria

**Test passes if ALL of the following are true:**

1. ✓ Passage A starts playing after step 5
2. ✓ Passage A stops immediately after step 8 (DELETE request)
3. ✓ Queue becomes empty after step 8
4. ✓ Playback state becomes "Stopped" after step 8
5. ✓ Passage B starts playing after step 12 (enqueue B)
6. ✓ Audio output after step 12 is passage B content, NOT passage A
7. ✓ Passage A audio does NOT resume at any point after step 8
8. ✓ Passage B plays to completion naturally after step 15
9. ✓ No errors in server logs
10. ✓ No unexpected SSE events

---

## Fail Criteria

**Test fails if ANY of the following occur:**

1. ✗ Passage A resumes playing after step 12 (THE BUG)
2. ✗ Passage B does not start after step 12
3. ✗ Passage B vanishes from queue before finishing
4. ✗ Audio output after step 12 is passage A instead of passage B
5. ✗ Server crashes or hangs
6. ✗ Decoder resources leaked (file handles not released)
7. ✗ Mixer continues reading stale chain data

---

## Verification Methods

### Audio Output Verification
**Method 1:** Manual listening
- Play test through speakers
- Human verifies passage A vs. B by ear

**Method 2:** Ring buffer inspection
- Monitor ring buffer contents after step 12
- Verify PCM samples match passage B, not passage A

**Method 3:** Decoder chain monitoring
- Use `/playback/buffer_chains` endpoint
- Verify chain assigned to passage B shows B's file path
- Verify no chain shows passage A's file path after step 8

### State Verification
- Use GET requests to verify queue and playback state
- Use SSE events to verify state transitions
- Check server logs for cleanup messages

### Resource Verification
- Check file handle count before/after
- Verify no memory leaks
- Verify decoder chain resources released

---

## Expected Behavior (Detailed)

### Step 8 (DELETE passage A) Should Trigger:
1. QueueManager::remove() called
2. Detects removed entry is current passage
3. Clears decoder chain for passage A:
   - Stops decoding
   - Closes file handle
   - Clears PCM buffer
   - Removes chain assignment
4. Clears mixer state:
   - Stops reading from A's chain
   - Resets playback position
   - Enters idle/stopped state
5. Updates queue structure (current → none)
6. Emits SSE events (queue empty, playback stopped)

### Step 12 (Enqueue passage B) Should Trigger:
1. QueueManager::enqueue() called
2. Passage B becomes current passage
3. Fresh decoder chain assigned to B
4. Decoder starts buffering B's audio
5. Mixer starts reading from B's chain
6. Playback begins with B's audio
7. Emits SSE events (queue updated, playback started)

**Key Difference from Bug:**
- Decoder chain for A is **completely cleared** at step 8
- Mixer has **no reference** to A's chain after step 8
- When B enqueued, mixer reads from **B's chain only**

---

## Test Data

### Test Audio File A
- **Path:** `/tmp/test_passage_a.mp3`
- **Duration:** 2 seconds
- **Content:** 440 Hz sine wave (A note) - clearly identifiable
- **Format:** MP3, 44.1kHz, stereo

### Test Audio File B
- **Path:** `/tmp/test_passage_b.mp3`
- **Duration:** 2 seconds
- **Content:** 880 Hz sine wave (A note, one octave higher) - clearly different from A
- **Format:** MP3, 44.1kHz, stereo

---

## Edge Cases Covered

- Passage fully buffered before removal (worst case for stale data)
- Delay between removal and enqueue (1 second wait)
- Different audio content (verifies correct passage playing)

---

## Notes

- This test directly reproduces the reported bug
- Failing this test = bug still exists
- Passing this test = bug is fixed
- Most critical test in the test suite

---

## Automation Potential

**Can be automated:** Yes (with test framework)
- HTTP requests: Easy to automate (reqwest crate)
- SSE events: Can monitor programmatically
- Audio verification: Harder, but can check chain assignments

**Manual verification recommended for initial testing:**
- Human ear verification for peace of mind
- Then automate for regression testing

---

## Related Tests

- **TC-S-001:** Tests immediate stop (no enqueue after)
- **TC-S-002:** Tests start next from queue (no delay)
- **TC-I-001:** Tests decoder cleanup mechanism
- **TC-I-002:** Tests mixer clearing mechanism
